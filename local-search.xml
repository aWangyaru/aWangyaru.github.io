<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常见面试题</title>
    <link href="/2021/05/14/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <url>/2021/05/14/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/</url>
    
    <content type="html"><![CDATA[<h3 id="1，箭头函数里的this"><a href="#1，箭头函数里的this" class="headerlink" title="1，箭头函数里的this"></a>1，箭头函数里的this</h3><h6 id="1-箭头函数：出现的作用除了让函数的书写变得很简洁，可读性很好外，最大的优点是解决了this执行环境多造成的一些问题。比如：解决了匿名函数this指向的问题-匿名函数的执行环境具有全局性-，包括setTimeout和setInterval中使用this所造成的问题"><a href="#1-箭头函数：出现的作用除了让函数的书写变得很简洁，可读性很好外，最大的优点是解决了this执行环境多造成的一些问题。比如：解决了匿名函数this指向的问题-匿名函数的执行环境具有全局性-，包括setTimeout和setInterval中使用this所造成的问题" class="headerlink" title="1,箭头函数：出现的作用除了让函数的书写变得很简洁，可读性很好外，最大的优点是解决了this执行环境多造成的一些问题。比如：解决了匿名函数this指向的问题(匿名函数的执行环境具有全局性)，包括setTimeout和setInterval中使用this所造成的问题."></a>1,箭头函数：出现的作用除了让函数的书写变得很简洁，可读性很好外，最大的优点是解决了this执行环境多造成的一些问题。比如：解决了匿名函数this指向的问题(匿名函数的执行环境具有全局性)，包括setTimeout和setInterval中使用this所造成的问题.</h6><p>我们常见的window属性和方法有alter、document、parseInt、setTimeout、setInterval、location等，这些在默认的情况下是省略了window前缀的. (window.alert = alert)</p><h6 id="2-普通函数中的this"><a href="#2-普通函数中的this" class="headerlink" title="2, 普通函数中的this"></a>2, 普通函数中的this</h6><p>普通函数，this的概念是： this是js的一个关键字，他是指函数执行过程中，自动生成的一个内部对象，是指当前的对象，只在当前函数内部使用。(this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this指向的是window，当函数被作为某个对象的方法调用时，this就等于那个对象)</p><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;#content&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> _t = <span class="hljs-built_in">this</span> <span class="hljs-comment">// 这里的this、_t都是#content的对象</span>    $(<span class="hljs-string">&#x27;.li&#x27;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        _t <span class="hljs-comment">// #content的this</span>        <span class="hljs-built_in">this</span> <span class="hljs-comment">// 循环每一个.li的this</span>    &#125;)&#125;)</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;this.window&#x27;</span><span class="hljs-keyword">var</span> object = &#123;    name: <span class="hljs-string">&#x27;my object&#x27;</span>,    getNameFun: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name        &#125;    &#125;&#125;<span class="hljs-built_in">console</span>.log(object.getNameFun()())  <span class="hljs-comment">// this.window</span></code></pre><p>匿名函数的执行环境是全局的，而且this只在函数内部起作用，所以打印结果是window. 此时this.name在匿名函数中找不到，所以全局中找，打印结果就是this.window</p><p>将上面的代码改装一下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> object = &#123;  name: <span class="hljs-string">&#x27;my object&#x27;</span>,  getNameFun: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;          <span class="hljs-keyword">return</span> that.name      &#125;  &#125;&#125;<span class="hljs-built_in">console</span>.log(object.getNameFun()()) <span class="hljs-comment">// my object</span></code></pre><p>在getNameFun内将this赋值给that，此时的that指向的是挂载(调用)的对象，即为object, 此时在匿名函数中调用that.name会在object上查找对应的数据，而不是在全局上查找，最终打印结果是my object</p><p>试着把函数的执行环境放在window下看看</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)&#125;test() <span class="hljs-comment">// window</span></code></pre><p>试着把函数的执行对象放在一个自定义变量上看看</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;  fun: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)  &#125;,  say: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;          <span class="hljs-built_in">console</span>.log(that)      &#125;)  &#125;&#125;obj.fun() <span class="hljs-comment">// obj</span>obj.say() <span class="hljs-comment">// obj</span></code></pre><p>setTimeout里的that指向的是obj，因为在say中this的绑定对象是obj，this赋给了that</p><p>为了更深一步理解this概念，来看一段代码并判断其运行结果</p><pre><code class="hljs kotlin">window.<span class="hljs-keyword">val</span> = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> obj = &#123;    <span class="hljs-keyword">val</span>: <span class="hljs-number">2</span>,    <span class="hljs-function"><span class="hljs-keyword">fun</span>: <span class="hljs-title">function</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> *= <span class="hljs-number">2</span>        <span class="hljs-keyword">val</span> *= <span class="hljs-number">2</span>        console.log(<span class="hljs-keyword">val</span>)        console.log(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span>)    &#125;&#125;obj.<span class="hljs-keyword">fun</span>()  // <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-keyword">var</span> func = obj.<span class="hljs-keyword">fun</span>func()  <span class="hljs-comment">// 8 8</span></code></pre><p>以上代码，这个函数中，obj.db1（）执行时，this.val是指obj里面的val=2，this.val*=2 =4;val在db1函数中并没有定义，所以默认情况下会在全局上找，此时val*=2=2。所以打印2 4。接着，定义一个func=obj.db1，我们把func打印出来看看是这样的：<br>ƒ () {<br>    this.val <em>= 2<br>    val <em>= 2<br>    console.log(val)<br>    console.log(this.val)<br>}<br>所以可以看出func的执行对象是window，我们可以此时全局的val已经等于4了，在经过this.val</em>=2,val</em>=2的运算，打印的结果就是8  8。</p><h6 id="3-箭头函数的this"><a href="#3-箭头函数的this" class="headerlink" title="3, 箭头函数的this"></a>3, 箭头函数的this</h6><p>箭头函数的this定义：箭头函数的this是在定义函数时绑定的，不是在执行过程中绑定的。简单的说，函数在定义时，this就继承了定义函数的对象。</p><p>所以，这会很好的解决匿名函数和setTimeout和setInterval的this指向问题。我们不用再去给其用that变量存储this。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;  fun: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)  &#125;,  say: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)      &#125;)  &#125;&#125;obj.fun() <span class="hljs-comment">// obj</span>obj.say() <span class="hljs-comment">// obj</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">this</span>.a = <span class="hljs-number">20</span>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a)  &#125;&#125;<span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> test()() <span class="hljs-comment">// 20</span></code></pre><h3 id="2-html-3种布局：-div-css、flex、grid"><a href="#2-html-3种布局：-div-css、flex、grid" class="headerlink" title="2,html 3种布局： div+css、flex、grid"></a>2,html 3种布局： div+css、flex、grid</h3><h6 id="1-div-css布局"><a href="#1-div-css布局" class="headerlink" title="1,div + css布局"></a>1,div + css布局</h6><p>也就是盒子布局，有W3C盒子模型，IE盒子模型。盒子模型由四部分组成margin、border、padding、content。<br>怎么区别这两种模型呢，区别在于w3c中的width是content的宽，IE的width是content+border+padding。</p><h6 id="2-flex-弹性布局"><a href="#2-flex-弹性布局" class="headerlink" title="2, flex 弹性布局"></a>2, flex 弹性布局</h6><p>通过使用display：flex；或者display：inline-flex；坏处就是不能再设置子元素的float、clear、vertical-align。</p><p>在这里面主要是在元素里建立主轴（main axis、横向的、水平的），交叉轴（cross axis、垂直的，竖向的）。主轴从左到右，左是main start，右是main end，之间是main size。交叉轴是从上到下，上是cross start，下是cross end，之间是cross size。</p><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/flex.png" srcset="/img/loading.gif" alt="flex"></p><p>举个例子</p><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">box</span>&quot;&gt;　　&lt;<span class="hljs-symbol">p</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">item</span>&quot;&gt;<span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">p</span>&gt;　　&lt;<span class="hljs-symbol">p</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">item</span>&quot;&gt;<span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">p</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre><p>在父元素div.box中可以设置的属性有六个：</p><p>1.flex-direction：row | row-reverse | column | column-reverse;</p><p>解释：这个主要用于设置子元素的排列顺序。row表示横向排列，从左到右；row-reverse表示横向排列，从右到左；column表示竖向排列，从上到下；column-reverse表示竖向排列，从下到上。</p><p>2.flex-warp:nowarp | warp | warp-reverse;</p><p>解释：设置元素的换行，nowarp表示不换行；warp表示换行，按一般的规律换到下面去；warp-reverse表示换行，不过换行是换到这一行的上面去。</p><p>3.flex-flow</p><p>解释：他是flex-direction和flex-warp的简写，默认值是row，nowarp。</p><p>4.justify-content： flex-start | center | flex-end | space-between | space-around ；</p><p>解释：元素在主轴上的对齐方式。 flex-start左对齐；center居中；flex-end右对齐；space-between两端对齐；space-around四周对齐。</p><p>5.align-items: flex-start | center | flex-end | baseline | stretch ;</p><p>解释：元素在交叉轴上的对齐方式。flex-start上对齐；center居中对齐； flex-end下对齐；baseline文字基线对齐；stretch没有高度或高度为auto时自动充满高度。</p><p>6.align-content：flex-start | center | flex-end | space-between | space-around | stretch；</p><p>解释：主轴和交叉轴同时出现时的对齐方式。flex-start左上角对齐；center中间对齐；flex-end右下角对齐；space-between两端对齐，轴线之间平均分布；space-around每根轴线两侧间隔线相等；stretch沿交叉轴方向填充。</p><p>子元素（div.item）的六个属性：</p><p>1.order：number ;</p><p>解释：设置元素的排列顺序，数值越小越靠前，默认为0。</p><p>2.flex-grow：number；</p><p>解释:元素放大的比例，默认为0.</p><p>3.flex-shrink：number；</p><p>解释：元素缩小比例，默认为1；</p><p>4.flex-basis：length | auto；</p><p>解释：元素占据的固定空间，默认auto。</p><p>5.flex：none| auto | 其他值；</p><p>解释：flex-grow、flex-shrink、flex-basis的简写，默认值为0，1，auto。none表示（0，0，auto），auto表示（1，1，auto）。</p><p>6.align-self：auto | flex-start | center | flex-end | baseline | baseline | stretch；</p><p>解释：允许单个元素与其他元素不一样的对齐方式，可覆盖align-items属性，默认值为auto，表示基础呢个父元素的align-items若无父元素，则等同于stretch</p><h3 id="3-grid网格布局"><a href="#3-grid网格布局" class="headerlink" title="3, grid网格布局"></a>3, grid网格布局</h3><p>网格布局（Grid）是最强大的 CSS 布局方案。</p><p>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。</p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/1_bg2019032501.png" srcset="/img/loading.gif" alt="1_bg2019032501" style="zoom:67%;" /><p>采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>上面代码中，最外层的<code>&lt;div&gt;</code>元素就是容器，内层的三个<code>&lt;div&gt;</code>元素就是项目。</p><p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的<code>&lt;p&gt;</code>元素就不是项目。Grid 布局只对项目生效。</p><p>容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。</p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/1_bg2019032502.png" srcset="/img/loading.gif" alt="1_bg2019032502" style="zoom: 67%;" /><p>上图中，水平的深色区域就是”行”，垂直的深色区域就是”列”。</p><p>行和列的交叉区域，称为”单元格”（cell）。</p><p>正常情况下，<code>n</code>行和<code>m</code>列会产生<code>n x m</code>个单元格。比如，3行3列会产生9个单元格。</p><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><p>正常情况下，<code>n</code>行有<code>n + 1</code>根水平网格线，<code>m</code>列有<code>m + 1</code>根垂直网格线，比如三行就有四根水平网格线。</p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/1_bg2019032503.png" srcset="/img/loading.gif" alt="img" style="zoom: 67%;" /><p>上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。</p><h6 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h6><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p><h6 id="1-display属性：-display-grid指定一个容器采用网格布局"><a href="#1-display属性：-display-grid指定一个容器采用网格布局" class="headerlink" title="1, display属性： display: grid指定一个容器采用网格布局"></a>1, display属性： display: grid指定一个容器采用网格布局</h6><p>Display默认是块级元素</p><pre><code class="hljs applescript">&lt;span&gt;wangyaru&lt;/span&gt;&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">3</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">4</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">5</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">6</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">7</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">8</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">9</span>&lt;/<span class="hljs-keyword">div</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;&lt;span&gt;wangyaru&lt;/span&gt;.wrap &#123;  display: grid;  grid-template-rows: <span class="hljs-number">100</span>px <span class="hljs-number">100</span>px <span class="hljs-number">100</span>px;  grid-template-columns: <span class="hljs-number">100</span>px <span class="hljs-number">100</span>px <span class="hljs-number">100</span>px;&#125;.wrap <span class="hljs-keyword">div</span> &#123;border: <span class="hljs-number">1</span>px solid rgb(<span class="hljs-number">60</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);&#125;</code></pre><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516024658835.png" srcset="/img/loading.gif" alt="image-20210516024658835" style="zoom:50%;" /><p>也可以设置为行内元素: display: inline-grid</p><pre><code class="hljs applescript">&lt;span&gt;wangyaru&lt;/span&gt;&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">3</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">4</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">5</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">6</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">7</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">8</span>&lt;/<span class="hljs-keyword">div</span>&gt;  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;<span class="hljs-number">9</span>&lt;/<span class="hljs-keyword">div</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;&lt;span&gt;wangyaru&lt;/span&gt;.wrap &#123;  display: inline-grid;  grid-template-rows: <span class="hljs-number">100</span>px <span class="hljs-number">100</span>px <span class="hljs-number">100</span>px;  grid-template-columns: <span class="hljs-number">100</span>px <span class="hljs-number">100</span>px <span class="hljs-number">100</span>px;&#125;.wrap <span class="hljs-keyword">div</span> &#123;border: <span class="hljs-number">1</span>px solid rgb(<span class="hljs-number">60</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);&#125;</code></pre><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516024627322.png" srcset="/img/loading.gif" alt="image-20210516024627322" style="zoom:50%;" /><h6 id="2-grid-template-columns属性、grid-template-rows属性"><a href="#2-grid-template-columns属性、grid-template-rows属性" class="headerlink" title="2, grid-template-columns属性、grid-template-rows属性"></a>2, grid-template-columns属性、grid-template-rows属性</h6><p>容器指定了网格布局以后，接着就是划分行和列。grid-tempate-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">display</span>: grid;<span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<span class="hljs-attribute">frid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;&#125;</code></pre><p>以上代码指定了一个三行三列的网格，列宽和行高都是<code>100px</code>。</p><p>除了使用绝对单位，也可以使用百分比。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: grid;  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span>;  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span>;&#125;</code></pre><h6 id="3-2-1-repeat"><a href="#3-2-1-repeat" class="headerlink" title="3.2.1, repeat()"></a>3.2.1, repeat()</h6><p>有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用<code>repeat()</code>函数，简化重复的值。上面的代码用<code>repeat()</code>改写如下。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: grid;  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);&#125;</code></pre><p><code>repeat()</code>接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。</p><p><code>repeat()</code>重复某种模式也是可以的。</p><pre><code class="hljs angelscript">grid-template-columns: repeat(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>px <span class="hljs-number">20</span>px <span class="hljs-number">80</span>px);</code></pre><p>上面代码定义了6列，第一列和第四列的宽度为<code>100px</code>，第二列和第五列为<code>20px</code>，第三列和第六列为<code>80px</code>。</p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516025053252.png" srcset="/img/loading.gif" alt="image-20210516025053252" style="zoom:50%;" /><h6 id="3-2-2-auto-fill关键字"><a href="#3-2-2-auto-fill关键字" class="headerlink" title="3.2.2, auto-fill关键字"></a>3.2.2, auto-fill关键字</h6><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用<code>auto-fill</code>关键字表示自动填充。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: grid;  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">100px</span>);&#125;</code></pre><p>上面代码表示每列宽度<code>100px</code>，然后自动填充，直到容器不能放置更多的列。</p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516025201586.png" srcset="/img/loading.gif" alt="image-20210516025201586" style="zoom:50%;" /><h6 id="3-2-3，fr关键字"><a href="#3-2-3，fr关键字" class="headerlink" title="3.2.3，fr关键字"></a>3.2.3，fr关键字</h6><p>为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: grid;  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;&#125;</code></pre><p>上面代码表示两个相同宽度的列。</p><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516025324404.png" srcset="/img/loading.gif" alt="image-20210516025324404"></p><p><code>fr</code>可以与绝对长度的单位结合使用，这时会非常方便。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: grid;  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr;&#125;</code></pre><p>上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的两半。</p><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516025401151.png" srcset="/img/loading.gif" alt="image-20210516025401151"></p><h6 id="3-2-4，minimax"><a href="#3-2-4，minimax" class="headerlink" title="3.2.4，minimax()"></a>3.2.4，minimax()</h6><p>Minimax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><pre><code class="hljs angelscript">grid-template-columns: <span class="hljs-number">1f</span>r <span class="hljs-number">1f</span>r minmax(<span class="hljs-number">100</span>px, <span class="hljs-number">1f</span>r);</code></pre><p>上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p><h6 id="3-2-5-auto-关键字"><a href="#3-2-5-auto-关键字" class="headerlink" title="3.2.5, auto 关键字"></a>3.2.5, auto 关键字</h6><p><code>auto</code>关键字表示由浏览器自己决定长度。</p><pre><code class="hljs angelscript">grid-template-columns: <span class="hljs-number">100</span>px <span class="hljs-built_in">auto</span> <span class="hljs-number">100</span>px;</code></pre><p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>，且这个值大于最大宽度。</p><h6 id="3-2-6-网格线的名称"><a href="#3-2-6-网格线的名称" class="headerlink" title="3.2.6, 网格线的名称"></a>3.2.6, 网格线的名称</h6><p><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: grid;  <span class="hljs-attribute">grid-template-columns</span>: [c1] <span class="hljs-number">100px</span> [c2] <span class="hljs-number">100px</span> [c3] auto [c4];  <span class="hljs-attribute">grid-template-rows</span>: [r1] <span class="hljs-number">100px</span> [r2] <span class="hljs-number">100px</span> [r3] auto [r4];&#125;</code></pre><p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p><p>网格布局允许同一根线有多个名字，比如<code>[fifth-line row-5]</code>。</p><h6 id="3-2-7-布局实例"><a href="#3-2-7-布局实例" class="headerlink" title="3.2.7, 布局实例"></a>3.2.7, 布局实例</h6><p><code>grid-template-columns</code>属性对于网页布局非常有用。两栏式布局只需要一行代码。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: grid;  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">70%</span> <span class="hljs-number">30%</span>;&#125;</code></pre><p>上面代码将左边栏设为70%，右边栏设为30%。</p><p>传统的十二网格布局，写起来也很容易:</p><pre><code class="hljs pgsql">grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">12</span>, <span class="hljs-number">1</span>fr)</code></pre><h6 id="4-grid-row-gap属性、grid-column-gap属性、grid-gap属性"><a href="#4-grid-row-gap属性、grid-column-gap属性、grid-gap属性" class="headerlink" title="4, grid-row-gap属性、grid-column-gap属性、grid-gap属性"></a>4, grid-row-gap属性、grid-column-gap属性、grid-gap属性</h6><p><code>grid-row-gap</code>属性设置行与行的间隔（行间距），<code>grid-column-gap</code>属性设置列与列的间隔（列间距）。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">grid-row-gap</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">grid-column-gap</span>: <span class="hljs-number">20px</span>;&#125;</code></pre><p>以上代码<code>grid-row-gap</code>用于设置行间距，<code>grid-column-gap</code>用于设置列间距。</p><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516025900047.png" srcset="/img/loading.gif" alt="image-20210516025900047"></p><p><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>的合并简写形式，语法如下。</p><pre><code class="hljs maxima"><span class="hljs-built_in">grid</span>-gap: &lt;<span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>-gap&gt; &lt;<span class="hljs-built_in">grid</span>-column-gap&gt;;</code></pre><p>因此，上面一段 CSS 代码等同于下面的代码</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span> <span class="hljs-number">20px</span>;&#125;</code></pre><p>如果<code>grid-gap</code>省略了第二个值，浏览器认为第二个值等于第一个值。</p><p>根据最新标准，上面三个属性名的<code>grid-</code>前缀已经删除，<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>，<code>grid-gap</code>写成<code>gap</code>。</p><h6 id="5-grid-template-areas属性"><a href="#5-grid-template-areas属性" class="headerlink" title="5, grid-template-areas属性"></a>5, grid-template-areas属性</h6><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: grid;  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;  <span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&#x27;a b c&#x27;</span>                       <span class="hljs-string">&#x27;d e f&#x27;</span>                       <span class="hljs-string">&#x27;g h i&#x27;</span>;&#125;</code></pre><p>上面代码先划分出9个单元格，然后将其定名为<code>a</code>到<code>i</code>的九个区域，分别对应这九个单元格。</p><p>多个单元格合并成一个区域的写法如下。</p><pre><code class="hljs sml">grid-template-areas: <span class="hljs-symbol">&#x27;a</span> a a&#x27;                     <span class="hljs-symbol">&#x27;b</span> b b&#x27;                     <span class="hljs-symbol">&#x27;c</span> c c&#x27;;</code></pre><p>上面代码将9个单元格分成<code>a</code>、<code>b</code>、<code>c</code>三个区域。</p><p>下面是一个布局实例。</p><pre><code class="hljs cpp">grid-<span class="hljs-keyword">template</span>-areas: <span class="hljs-string">&quot;header header header&quot;</span>                     <span class="hljs-string">&quot;main main sidebar&quot;</span>                     <span class="hljs-string">&quot;footer footer footer&quot;</span>;</code></pre><p>上面代码中，顶部是页眉区域<code>header</code>，底部是页脚区域<code>footer</code>，中间部分则为<code>main</code>和<code>sidebar</code>。</p><p>如果某些区域不需要利用，则使用”点”（<code>.</code>）表示。</p><pre><code class="hljs sml">grid-template-areas: <span class="hljs-symbol">&#x27;a</span> . c&#x27;                     <span class="hljs-symbol">&#x27;d</span> . f&#x27;                     <span class="hljs-symbol">&#x27;g</span> . i&#x27;;</code></pre><p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p><p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><p>比如，区域名为<code>header</code>，则起始位置的水平网格线和垂直网格线叫做<code>header-start</code>，终止位置的水平网格线和垂直网格线叫做<code>header-end</code>。</p><h6 id="6-grid-auto-flow-属性"><a href="#6-grid-auto-flow-属性" class="headerlink" title="6, grid-auto-flow 属性"></a>6, grid-auto-flow 属性</h6><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。</p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516030712086.png" srcset="/img/loading.gif" alt="image-20210516030712086" style="zoom:50%;" /><p>这个顺序由<code>grid-auto-flow</code>属性决定，默认值是<code>row</code>，即”先行后列”。也可以将它设成<code>column</code>，变成”先列后行”。</p><pre><code class="hljs mel"><span class="hljs-keyword">grid</span>-auto-<span class="hljs-keyword">flow</span>: column;</code></pre><p>上面代码设置了column以后，放置顺序就变成了下图</p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516030733736.png" srcset="/img/loading.gif" alt="image-20210516030733736" style="zoom:50%;" /><p><code>grid-auto-flow</code>属性除了设置成<code>row</code>和<code>column</code>，还可以设成<code>row dense</code>和<code>column dense</code>。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p><p>下面的例子让1号项目和2号项目各占据两个单元格，然后在默认的<code>grid-auto-flow: row</code>情况下，会产生下面这样的布局。</p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516031321065.png" srcset="/img/loading.gif" alt="image-20210516031321065" style="zoom:50%;" /><p>上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。</p><p>现在修改设置，设为<code>row dense</code>，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p><pre><code class="hljs maxima"><span class="hljs-built_in">grid</span>-auto-flow: <span class="hljs-built_in">row</span> dense;</code></pre><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516031351845.png" srcset="/img/loading.gif" alt="image-20210516031351845" style="zoom:50%;" /><p>上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。</p><p>如果将设置改为<code>column dense</code>，表示”先列后行”，并且尽量填满空格。</p><pre><code class="hljs mel"><span class="hljs-keyword">grid</span>-auto-<span class="hljs-keyword">flow</span>: column dense;</code></pre><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516031433226.png" srcset="/img/loading.gif" alt="image-20210516031433226" style="zoom:50%;" /><p>上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列</p><h6 id="7-justify-items属性、align-items属性、place-items属性"><a href="#7-justify-items属性、align-items属性、place-items属性" class="headerlink" title="7, justify-items属性、align-items属性、place-items属性"></a>7, justify-items属性、align-items属性、place-items属性</h6><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">justify-items</span>: start | end | center | stretch;  <span class="hljs-attribute">align-items</span>: start | end | center | stretch;&#125;</code></pre><p>这两个属性的写法完全相同，都可以取下面这些值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">justify-items</span>: start;&#125;</code></pre><p>以上代码表示，单元格的内容左对齐，效果如下图。</p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516032125354.png" srcset="/img/loading.gif" alt="image-20210516032125354" style="zoom:50%;" /><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">align-items</span>: start;&#125;</code></pre><p>以上代码表示，单元格的内容头部对齐，效果如下图。</p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516032200156.png" srcset="/img/loading.gif" alt="image-20210516032200156" style="zoom:50%;" /><p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。</p><pre><code class="hljs sqf">place-<span class="hljs-built_in">items</span>: &lt;align-<span class="hljs-built_in">items</span>&gt; &lt;justify-<span class="hljs-built_in">items</span>&gt;;</code></pre><p>下面是一个例子:</p><pre><code class="hljs sql">place-items: <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>;</code></pre><p>如果省略第二个值，则浏览器认为与第一个值相等</p><h6 id="8-justify-content-属性，-align-content-属性，-place-content-属性"><a href="#8-justify-content-属性，-align-content-属性，-place-content-属性" class="headerlink" title="8, justify-content 属性， align-content 属性， place-content 属性"></a>8, justify-content 属性， align-content 属性， place-content 属性</h6><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</p><pre><code class="hljs applescript">.container &#123;  justify-content: start | <span class="hljs-keyword">end</span> | center | stretch | <span class="hljs-literal">space</span>-<span class="hljs-keyword">around</span> | <span class="hljs-literal">space</span>-<span class="hljs-keyword">between</span> | <span class="hljs-literal">space</span>-evenly;  align-content: start | <span class="hljs-keyword">end</span> | center | stretch | <span class="hljs-literal">space</span>-<span class="hljs-keyword">around</span> | <span class="hljs-literal">space</span>-<span class="hljs-keyword">between</span> | <span class="hljs-literal">space</span>-evenly;  &#125;</code></pre><p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以<code>justify-content</code>属性为例，<code>align-content</code>属性的图完全一样，只是将水平方向改成垂直方向。）</p><pre><code class="hljs crmsh"><span class="hljs-literal">start</span> - 对齐容器的起始边框。</code></pre><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516035732997.png" srcset="/img/loading.gif" alt="image-20210516035732997" style="zoom:50%;" /><pre><code class="hljs ada"><span class="hljs-keyword">end</span> - 对齐容器的结束边框。</code></pre><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516035756702.png" srcset="/img/loading.gif" alt="image-20210516035756702"></p><pre><code class="hljs maxima"><span class="hljs-built_in">center</span> - 容器内部居中。</code></pre><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516035819805.png" srcset="/img/loading.gif" alt="image-20210516035819805"></p><pre><code class="hljs nginx"><span class="hljs-attribute">stretch</span> - 项目大小没有指定时，拉伸占据整个网格容器。</code></pre><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516035933415.png" srcset="/img/loading.gif" alt="image-20210516035933415"></p><pre><code class="hljs applescript"><span class="hljs-literal">space</span>-<span class="hljs-keyword">around</span> - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</code></pre><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516040034814.png" srcset="/img/loading.gif" alt="image-20210516040034814"></p><pre><code class="hljs applescript"><span class="hljs-literal">space</span>-<span class="hljs-keyword">between</span> - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</code></pre><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516040058889.png" srcset="/img/loading.gif" alt="image-20210516040058889"></p><pre><code class="hljs applescript"><span class="hljs-literal">space</span>-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</code></pre><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516040123690.png" srcset="/img/loading.gif" alt="image-20210516040123690"></p><p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</p><pre><code class="hljs maxima">place-<span class="hljs-built_in">content</span>: &lt;align-<span class="hljs-built_in">content</span>&gt; &lt;justify-<span class="hljs-built_in">content</span>&gt;</code></pre><pre><code class="hljs applescript">place-content: <span class="hljs-literal">space</span>-<span class="hljs-keyword">around</span> <span class="hljs-literal">space</span>-evenly;</code></pre><p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p><h6 id="9-grid-auto-columns-属性，-grid-auto-rows-属性"><a href="#9-grid-auto-columns-属性，-grid-auto-rows-属性" class="headerlink" title="9, grid-auto-columns 属性， grid-auto-rows 属性"></a>9, grid-auto-columns 属性， grid-auto-rows 属性</h6><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><p>下面的例子，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: grid;  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">50px</span>; &#125;</code></pre><p>上面代码指定新增的行高统一为50px（原始的行高为100px）。</p><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516040530981.png" srcset="/img/loading.gif" alt="image-20210516040530981"></p><h6 id="10-grid-template-属性，-grid-属性"><a href="#10-grid-template-属性，-grid-属性" class="headerlink" title="10, grid-template 属性， grid 属性"></a>10, grid-template 属性， grid 属性</h6><p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p><p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p><p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p><h5 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h5><h6 id="1-grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性"><a href="#1-grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性" class="headerlink" title="1, grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性"></a>1, grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性</h6><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><ul><li><code>grid-column-start</code>属性：左边框所在的垂直网格线</li><li><code>grid-column-end</code>属性：右边框所在的垂直网格线</li><li><code>grid-row-start</code>属性：上边框所在的水平网格线</li><li><code>grid-row-end</code>属性：下边框所在的水平网格线</li></ul><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;  <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">2</span>;  <span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">4</span>;&#125;</code></pre><p>以上代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。</p><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516040738881.png" srcset="/img/loading.gif" alt="image-20210516040738881"></p><p>上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p><p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的<code>grid-auto-flow</code>属性决定，这个属性的默认值是<code>row</code>，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成<code>column</code>、<code>row dense</code>和<code>column dense</code>，看看其他项目的位置发生了怎样的变化。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;  <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">3</span>;  <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">2</span>;  <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">4</span>;&#125;</code></pre><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516040941534.png" srcset="/img/loading.gif" alt="image-20210516040941534"></p><p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;  <span class="hljs-attribute">grid-column-start</span>: header-start;  <span class="hljs-attribute">grid-column-end</span>: header-end;&#125;</code></pre><p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p><p>这四个属性的值还可以使用<code>span</code>关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;  <span class="hljs-attribute">grid-column-start</span>: span <span class="hljs-number">2</span>;&#125;</code></pre><p>以上代码，1号项目的左边框距离右边框跨越2个网格。</p><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516041342929.png" srcset="/img/loading.gif" alt="image-20210516041342929"></p><p>这与下面的效果完全一样。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;  <span class="hljs-attribute">grid-column-end</span>: span <span class="hljs-number">2</span>;&#125;</code></pre><p>使用这四个属性，如果产生了项目的重叠，则使用<code>z-index</code>属性指定项目的重叠顺序。</p><h6 id="2-grid-column-属性，-grid-row-属性"><a href="#2-grid-column-属性，-grid-row-属性" class="headerlink" title="2,grid-column 属性， grid-row 属性"></a>2,grid-column 属性， grid-row 属性</h6><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><pre><code class="hljs pgsql">.item &#123;  grid-<span class="hljs-keyword">column</span>: &lt;<span class="hljs-keyword">start</span>-<span class="hljs-type">line</span>&gt; / &lt;<span class="hljs-keyword">end</span>-<span class="hljs-type">line</span>&gt;;  grid-<span class="hljs-keyword">row</span>: &lt;<span class="hljs-keyword">start</span>-<span class="hljs-type">line</span>&gt; / &lt;<span class="hljs-keyword">end</span>-<span class="hljs-type">line</span>&gt;;&#125;</code></pre><p>下面是一个例子。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">/* 等同于 */</span><span class="hljs-selector-class">.item-1</span> &#123;  <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">3</span>;  <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">2</span>;&#125;</code></pre><p>上面代码中，项目<code>item-1</code>占据第一行，从第一根列线到第三根列线。</p><p>这两个属性之中，也可以使用<code>span</code>关键字，表示跨越多少个网格。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#b03532</span>;  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;&#125;<span class="hljs-comment">/* 等同于 */</span><span class="hljs-selector-class">.item-1</span> &#123;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#b03532</span>;  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;&#125;</code></pre><p>以上代码，项目<code>item-1</code>占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516041741041.png" srcset="/img/loading.gif" alt="image-20210516041741041"></p><p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;&#125;</code></pre><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516041814053.png" srcset="/img/loading.gif" alt="image-20210516041814053"></p><h6 id="3-grid-area-属性"><a href="#3-grid-area-属性" class="headerlink" title="3, grid-area 属性"></a>3, grid-area 属性</h6><p><code>grid-area</code>属性指定项目放在哪一个区域。</p><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span> &#123;  <span class="hljs-attribute">display</span>: grid;  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">50px</span>;  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">253</span>, <span class="hljs-number">238</span>, <span class="hljs-number">245</span>);  <span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&#x27;a b c&#x27;</span> <span class="hljs-string">&#x27;d wangyaru f&#x27;</span> <span class="hljs-string">&#x27;g h i&#x27;</span>;&#125;<span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">grid-area</span>: wangyaru&#125;</code></pre><p>以上代码，1号项目位于wangyaru区域:</p><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516042051972.png" srcset="/img/loading.gif" alt="image-20210516042051972"></p><p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><pre><code class="hljs pgsql">.item &#123;  grid-area: &lt;<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>&gt; / &lt;<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>&gt; / &lt;<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>&gt; / &lt;<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>&gt;;&#125;</code></pre><pre><code class="hljs angelscript">.item<span class="hljs-number">-1</span> &#123;  grid-area: <span class="hljs-number">1</span> / <span class="hljs-number">1</span> / <span class="hljs-number">3</span> / <span class="hljs-number">3</span>;&#125;</code></pre><p><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516042156852.png" srcset="/img/loading.gif" alt="image-20210516042156852"></p><h5 id="4-justify-self-属性，-align-self-属性，-place-self-属性"><a href="#4-justify-self-属性，-align-self-属性，-place-self-属性" class="headerlink" title="4,justify-self 属性， align-self 属性， place-self 属性"></a>4,justify-self 属性， align-self 属性， place-self 属性</h5><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">justify-self</span>: start | end | center | stretch;  <span class="hljs-attribute">align-self</span>: start | end | center | stretch;&#125;</code></pre><p>这两个属性都可以取下面四个值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul><p>下面是<code>justify-self: start</code>的例子。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span>  &#123;  <span class="hljs-attribute">justify-self</span>: start;&#125;</code></pre><img src="/images/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982/image-20210516042255343.png" srcset="/img/loading.gif" alt="image-20210516042255343" style="zoom: 50%;" /><p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p><blockquote><pre><code class="hljs css"><span class="hljs-selector-tag">place-self</span>: &lt;<span class="hljs-selector-tag">align-self</span>&gt; &lt;<span class="hljs-selector-tag">justify-self</span>&gt;</code></pre></blockquote><p>下面是一个例子。</p><blockquote><pre><code class="hljs css"><span class="hljs-selector-tag">place-self</span>: <span class="hljs-selector-tag">center</span> <span class="hljs-selector-tag">center</span></code></pre></blockquote><p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见面试题</title>
    <link href="/2021/05/14/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/05/14/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1，var-let-const-区别"><a href="#1，var-let-const-区别" class="headerlink" title="1，var let const 区别"></a>1，var let const 区别</h3><p>1，作用域不同(是否含有块级元素)： var没有块级作用域，let const 有<br>块级作用域：声明的变量只在该代码块作用域内有效<br>2，暂时性死区：只要块级作用域有let const，他们声明的变量就绑定这个区域，不受外界影响<br>3，是否存在变量提升<br>变量提升： 变量在声明之前是否可用<br>var声明的存在变量提升。let const声明的不存在变量提升</p><pre><code class="hljs livecodeserver">console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>)<span class="hljs-comment"> // undefined</span>var <span class="hljs-keyword">a</span> = <span class="hljs-number">10</span>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>)<span class="hljs-comment"> // 报错：Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span>let <span class="hljs-keyword">a</span> = <span class="hljs-number">10</span> || const <span class="hljs-keyword">a</span> = <span class="hljs-number">10</span></code></pre><p>4,能否重复声明<br>var声明的可以重复声明。let const不能</p><pre><code class="hljs livecodeserver">var <span class="hljs-keyword">a</span> = <span class="hljs-number">10</span>var <span class="hljs-keyword">a</span> = <span class="hljs-number">20</span>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>)<span class="hljs-comment"> // 20</span>var <span class="hljs-keyword">a</span> = <span class="hljs-number">10</span>let <span class="hljs-keyword">a</span> = <span class="hljs-number">20</span> || const <span class="hljs-keyword">a</span> = <span class="hljs-number">20</span>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>)<span class="hljs-comment"> // 报错：Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></code></pre><p>5，变量能否被修改<br>var let 声明的可以被修改，const声明的常量不可以被修改</p><pre><code class="hljs livecodeserver">var <span class="hljs-keyword">a</span> = <span class="hljs-number">10</span> || let <span class="hljs-keyword">a</span> = <span class="hljs-number">10</span><span class="hljs-keyword">a</span> = <span class="hljs-number">20</span>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>)<span class="hljs-comment"> // 20</span>const <span class="hljs-keyword">a</span> = <span class="hljs-number">10</span><span class="hljs-keyword">a</span> = <span class="hljs-number">20</span>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>)<span class="hljs-comment"> // 报错：Uncaught TypeError: Assignment to constant variable.</span></code></pre><h3 id="2-rem-em区别"><a href="#2-rem-em区别" class="headerlink" title="2, rem em区别"></a>2, rem em区别</h3><p>rem是基于html根元素的字体大小来决定的<br>em是基于父元素的字体大小来决定的，如果当前元素的字体大小没有被设置的话，就会继承父元素的字体大小<br> rem出现是为了解决em的缺陷：em是相对父元素的字体大小决定的，当父元素字体大小改变时，需要重新计算，rem可以解决这个问题，rem只相对html元素</p><h3 id="3，事件委托，事件冒泡和事件捕获，阻止事件冒泡"><a href="#3，事件委托，事件冒泡和事件捕获，阻止事件冒泡" class="headerlink" title="3，事件委托，事件冒泡和事件捕获，阻止事件冒泡"></a>3，事件委托，事件冒泡和事件捕获，阻止事件冒泡</h3><p>事件委托(事件代理)，把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务，事件代理的原理是DOM元素的事件冒泡。</p><p>事件冒泡，事件按照从最特定的事件目标到最不特定的事件目标。<br>​事件捕获与事件冒泡相反，事件从最外层开始发生，直到最具体的元素</p><p>阻止事件冒泡： 1，e.stopPropagation()</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> dv1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#div1&#x27;</span>)<span class="hljs-keyword">let</span> dv2 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#div2&#x27;</span>)<span class="hljs-keyword">let</span> dv3 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#div3&#x27;</span>)dv1.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.id)  <span class="hljs-comment">// div1</span>&#125;dv2.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.id)  <span class="hljs-comment">// div2 div1</span>&#125;dv3.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.id)  <span class="hljs-comment">// div3</span>  e.stopPropagation()&#125;</code></pre><p>2,window.event.cancelBubble = true (谷歌、IE浏览器兼容，不兼容火狐浏览器)</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> dv1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#div1&#x27;</span>)<span class="hljs-keyword">let</span> dv2 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#div2&#x27;</span>)<span class="hljs-keyword">let</span> dv3 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#div3&#x27;</span>)dv1.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.id)  <span class="hljs-comment">// div1</span>&#125;dv2.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.id)  <span class="hljs-comment">// div2 div1</span>&#125;dv3.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.id)  <span class="hljs-comment">// div3</span>  <span class="hljs-built_in">window</span>.event.cancelBubble = <span class="hljs-literal">true</span>&#125;</code></pre><h3 id="3-浏览器从输入url到页面加载发生了什么？"><a href="#3-浏览器从输入url到页面加载发生了什么？" class="headerlink" title="3,浏览器从输入url到页面加载发生了什么？"></a>3,浏览器从输入url到页面加载发生了什么？</h3><p>1, DNS解析(网址解析成IP地址)，即DNS解析就是从输入的url到寻找IP地址的一个过程<br>2，TCP连接(三次握手)<br>第一次握手：客户端发送给服务器端，请求建立连接，第一次握手说明客户端有发送信息的能力<br>第二次握手：服务器接到客户端的请求会回复客户端，第二次握手说明服务器端有接受信息和发送信息的能力<br>第三次握手：客户端接收到服务器端的回复会告诉服务器接收到信息。第三次握手说明客户端具有接收信息的能力<br>3，发送HTTP请求<br>4，服务端处理请求，并返回HTTP报文<br>5，浏览器解析并渲染页面<br>6，终止TCP(四次挥手)<br>第一次挥手：客户端发送给服务器，用来关闭客户端到服务器端的数据传送<br>第二次挥手：服务器接收到客户端的请求，并返回一个ACK报文<br>第三次挥手：服务端关闭客户端的连接，发送一个FIN给客户端<br>第四次挥手：客户端收到并发送ACK报文确认，并将服务端发送的FIN序号 + 1</p><h3 id="4-跨域"><a href="#4-跨域" class="headerlink" title="4, 跨域"></a>4, 跨域</h3><p>1，为什么会出现跨域问题<br>出于浏览器的同源策略限制， 所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。<br>当一个请求url的协议、域名、端口任意一个与当前页面的url不同就是跨域</p><table><thead><tr><th>当前页面url</th><th>被请求页面url</th><th>是否跨域</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="http://www.test.com/index.html">http://www.test.com/index.html</a></td><td>否</td><td>同源(协议、域名、端口相同)</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td><a href="https://www.test.com/index.html">https://www.test.com/index.html</a></td><td>跨域</td><td>协议不同(http/https)</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com</a></td><td><a href="http://www.baidu.com/">http://www.baidu.com</a></td><td>跨域</td><td>主域名不同(test/baidu)</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com</a></td><td><a href="http://blog.test.com/">http://blog.test.com</a></td><td>跨域</td><td>子域名不同(www/blog)</td></tr><tr><td><a href="http://www.test.com:8080/">http://www.test.com:8080</a></td><td><a href="http://www.test.com:7000/">http://www.test.com:7000</a></td><td>跨域</td><td>端口不同(8080/7000)</td></tr><tr><td>跨域解决方案：</td><td></td><td></td><td></td></tr><tr><td>1，document.domain解决无法读取非同源网页的cookie问题</td><td></td><td></td><td></td></tr><tr><td>因为浏览器是通过document.domain来检查两个页面是否同源，因此只要设置相同的document.domain，两个页面就可以共享cookie</td><td></td><td></td><td></td></tr></tbody></table><p>2, window.postMessage()<br>调用postMessage方法实现父窗口<a href="http://test1.com向子窗口http//test2.com%E5%8F%91%E6%B6%88%E6%81%AF%EF%BC%8C">http://test1.com向子窗口http://test2.com发消息，</a> （子窗口同样可以使用该方法发送消息给父组件）<br>主要解决以下问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递<pre><code class="hljs reasonml"><span class="hljs-comment">// 父窗口打开一个子窗口</span>var openWindwo = window.<span class="hljs-keyword">open</span>(&#x27;http:<span class="hljs-comment">//test2.com&#x27;, &#x27;title&#x27;)</span><span class="hljs-comment">// 父窗口向子窗口发消息（第一个参数代表发送的内容，第二个参数代表接受消息窗口的url）</span>openWindow.post<span class="hljs-constructor">Message(&#x27;<span class="hljs-params">nice</span> <span class="hljs-params">to</span> <span class="hljs-params">meet</span> <span class="hljs-params">you</span>&#x27;, &#x27;<span class="hljs-params">http</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">test2</span>.<span class="hljs-params">com</span>&#x27;)</span></code></pre>调用message事件，监听对方发送的消息<pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(e.source) <span class="hljs-comment">// e.source发送消息的窗口</span>  <span class="hljs-built_in">console</span>.log(e.origin) <span class="hljs-comment">// e,origin消息发向的网址</span>  <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">// e.data 发送的消息</span>&#125;, <span class="hljs-literal">false</span>)</code></pre>3, JSONP<br>jsonp是服务器与客户端跨源通信的常用方法，最大特点是简单适用，兼容性好，缺点是只支持get请求，不支持post请求。<br>核心思想：网页通过添加一个script元素，向服务器请求JSON数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传过来</li></ul><p>原生JS实现</p><pre><code class="hljs javascript"><span class="hljs-comment">// 向服务器test.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字</span>&lt;script src=<span class="hljs-string">&quot;http://test.com/data.php?callback=dosomething&quot;</span>&gt;&lt;/script&gt;<span class="hljs-comment">// 处理服务器返回的回调函数的数据</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dosomething</span> (<span class="hljs-params">res</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(res.data)&#125;</code></pre><p>jQuery实现</p><pre><code class="hljs scilab">$.ajax(&#123;  url: <span class="hljs-string">&#x27;http://www.test.com:8080/login&#x27;</span>,  <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;get&#x27;</span>,  dataType: <span class="hljs-string">&#x27;jsonp&#x27;</span>, <span class="hljs-comment">// 请求方式为jsonp</span>  jsonCallback: <span class="hljs-string">&quot;handleCallback&#x27;</span>,  <span class="hljs-comment">//自定义回调函数名称</span>  data: &#123;&#125;&#125;)</code></pre><p>vue实现</p><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$http.jsonp(<span class="hljs-string">&#x27;http://test.com:8080/login&#x27;</span>, &#123;  params: &#123;&#125;,  jsonp: <span class="hljs-string">&#x27;handleCallback&#x27;</span>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(res)&#125;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue常见面试题</title>
    <link href="/2021/05/09/Vue/"/>
    <url>/2021/05/09/Vue/</url>
    
    <content type="html"><![CDATA[<h6 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h6><p>vue的创建、使用、销毁过程会有很多事件，这些事件统称为生命周期函数。</p><h6 id="生命周期包括"><a href="#生命周期包括" class="headerlink" title="生命周期包括"></a>生命周期包括</h6><p>创建期间生命周期函数：beforeCreate、created、beforeMount、Mounted<br>运行期间生命周期函数：beforeUpdate、updated<br>销毁期间生命周期函数：beforeDestory、destoryed</p><h6 id="介绍生命周期"><a href="#介绍生命周期" class="headerlink" title="介绍生命周期"></a>介绍生命周期</h6><p>1，创建阶段<br>beforeCreate：此时vue实例还没有被完全创建出来，data、methods等内部还没有初始化，这时候在函数内调用数据的话，会显示undefined</p><p>created： vue实例已经被初始化了，可以调用数据，不过还没渲染到页面上。在当前函数中可以访问到data中的属性，会将data中的属性和methods的方法添加到vue的实例上，同时会将data中的所有属性添加一个getter/setter方法。</p><p>beforeMount: Vue将模版字符串编译成内存DOM，模版已经编译完成，还没有渲染到页面上</p><p>Mounted： 创建阶段完成，页面渲染完毕。此时可以通过$refs来访问到真实的DOM结构。ref类似id一样是唯一的，访问的时候可以使用</p><p>2，运行阶段<br>beforeUpdate: 内存中的数据已经改变，页面上的还没有更新<br>updated：页面上数据和内存中的一致</p><p>3，销毁阶段<br>beforeDestory： 此时还没有销毁，data、methods指令都还在正常运行。这个声明周期中我们可以将绑定的事件移除<br>destoryed： 组件销毁完毕，data、methods、指令之类的不可用</p><h6 id="vue双向数据绑定原理"><a href="#vue双向数据绑定原理" class="headerlink" title="vue双向数据绑定原理"></a>vue双向数据绑定原理</h6><p>主要是采用数据劫持 结合 订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的getter、setter，在数据变动时发布消息给订阅者，触发相应监听回调</p><h6 id="模版语法-插值"><a href="#模版语法-插值" class="headerlink" title="模版语法 - 插值"></a>模版语法 - 插值</h6><p>数据绑定最常见的形式就是双大括号的文本插值</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="xml">v-once指令，一次性的插值，当数据变化时，插值处的内容不会更新。</span></code></pre><p>双大括号不会让数据解释为普通文本，而非html代码。为了输出的是真正的html代码，可以使用v-html指令</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;rawHTML&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre><p>v-bind指令</p><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> v-bind:disabled=<span class="hljs-string">&quot;isButtonDisabled&quot;</span>&gt;<span class="hljs-keyword">Button</span>&lt;/<span class="hljs-keyword">button</span>&gt;</code></pre><p>如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled attribute 甚至不会被包含在渲染出来的button元素中。</p><h6 id="模版语法-指令"><a href="#模版语法-指令" class="headerlink" title="模版语法 - 指令"></a>模版语法 - 指令</h6><p>指令是带有 v- 前缀的特殊属性，指令的指责是，当表达式的值改变的时候，将其产生的连待影响，影响式的作用于DOM<br>v-if<br>v-bind<br>v-once<br>v-html<br>v-on</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>在这里href是参数，告知bind将该元素的href属性与表达式url的值绑定</code></pre><pre><code class="hljs livecodeserver">&lt;<span class="hljs-keyword">a</span> v-<span class="hljs-keyword">on</span>:<span class="hljs-title">click</span>=<span class="hljs-string">&quot;click&quot;</span>&gt;...&lt;/<span class="hljs-title">a</span>&gt;v-<span class="hljs-keyword">on</span>指令用于监听<span class="hljs-title">DOM</span>事件</code></pre><p>修饰符： .prevent 告诉v-on对于触发的事件调用event.preventDefault()</p><h6 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h6><p>模版内的表达式非常便利，但是设计他们的初衷是用于简单运算的。在模版中放入太多的逻辑会让模版过重且难以维护，所以对于复杂的逻辑，应使用计算属性</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">msg</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">reverseMsg</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">export default &#123;</span><span class="xml">  data () &#123;</span><span class="xml">    return &#123;</span><span class="xml">      msg: &#x27;wangyaru&#x27;</span><span class="xml">    &#125;</span><span class="xml">  &#125;,</span><span class="xml">  computed: &#123;</span><span class="xml">    reverseMsg: function () &#123;</span><span class="xml">      return this.msg.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><span class="xml">    &#125;</span><span class="xml">  &#125;</span><span class="xml">&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><p>wangyaru<br>uraygnaw</p><p>计算属性缓存vs方法<br>我们可以通过在表达式中调用方法来达到同样的效果</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">msg</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">reverseMsg</span>()&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">export default &#123;</span><span class="xml">  name: &#x27;App&#x27;,</span><span class="xml">  components: &#123;</span><span class="xml">  &#125;,</span><span class="xml">  data () &#123;</span><span class="xml">    return &#123;</span><span class="xml">      msg: &#x27;wangyaru&#x27;</span><span class="xml">    &#125;</span><span class="xml">  &#125;,</span><span class="xml">  computed: &#123;</span><span class="xml">    </span><span class="xml">  &#125;,</span><span class="xml">  methods: &#123;</span><span class="xml">    reverseMsg: function () &#123;</span><span class="xml">      return this.msg.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><span class="xml">    &#125;</span><span class="xml">  &#125;</span><span class="xml">&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><p>计算属性是基于vue的响应式依赖进行缓存的，只在相关响应式依赖发生改变时他们才会重新求值</p><p>这就意味着只要 msg 没有发生改变，多次访问reverseMsg 计算属性会立即返回之前的计算结果，而不必再次执行函数</p><p>这也就意味着下面的计算属性将不再更新，因为Date.now()不是响应式依赖：</p><pre><code class="hljs css"><span class="hljs-selector-tag">computed</span>: &#123;  <span class="hljs-attribute">now</span>: function () &#123;    return Date.<span class="hljs-built_in">now</span>()  &#125;&#125;</code></pre><p>相比之下，每次触发重新渲染时，调用方法总会再次执行函数。</p><h6 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h6><p>Vue提供了一种更通用的方式来观察和响应Vue实例上的数据变动：侦听属性。当一些数据需要随着其他数据变动而变动时，通常使用计算属性而不是命令式的watch回调。</p><pre><code class="hljs kotlin">&lt;span&gt;&#123;&#123; fullName &#125;&#125;&lt;/span&gt;watch: &#123;  firstName: function (<span class="hljs-keyword">val</span>) &#123;    <span class="hljs-keyword">this</span>.fullName = <span class="hljs-keyword">val</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-keyword">this</span>.lastName  &#125;,  lastName: function (<span class="hljs-keyword">val</span>) &#123;    <span class="hljs-keyword">this</span>.fullName = <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-keyword">val</span>  &#125;  <span class="hljs-comment">// 改为深度监听</span>  firstName: &#123;    handler(newVal, oldVal) &#123;      <span class="hljs-keyword">this</span>.fullName = newVal  + <span class="hljs-string">&#x27;--&#x27;</span> + <span class="hljs-keyword">this</span>.lastName    &#125;,    immediate: <span class="hljs-literal">true</span>  <span class="hljs-comment">// watch监听，最初绑定的时候是不会执行的，要等到firstName改变时才执行watch方法，那我们想一开始就让他最初绑定的时候就执行，就需要immediate为true</span>    deep: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 深度监听</span>  &#125;&#125;</code></pre><p>以上代码是watch监听且重复，将它与计算属性相比：</p><pre><code class="hljs actionscript">computed: &#123;  fullName: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">&#x27;--&#x27;</span> + <span class="hljs-keyword">this</span>.lastName  &#125;&#125;</code></pre><p>好的多，不是吗？</p><h6 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h6><p>计算属性默认只有getter，不过在需要时也可以提供一个setter</p><pre><code class="hljs plain"></code></pre><h6 id="方法调用、compunted、watch区别"><a href="#方法调用、compunted、watch区别" class="headerlink" title="方法调用、compunted、watch区别"></a>方法调用、compunted、watch区别</h6><p>方法调用：</p><ul><li>页面数据每次重新渲染都会重新执行。性能消耗大，不会有缓存</li><li>除非不希望有缓存，一般都不会用方法<br>computed：</li><li>computed是计算属性，依赖其他属性计算值</li><li>computed里的属性不能和data里的重复，后台会有警告， watch里的属性data里必须得有对应的数据</li><li>computed 必须有返回值</li><li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li><li>不支持异步，当computed内有异步操作时无效，无法监听数据变化</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，或者处理复杂数据时使用computed, 多对一、一对一时用computed</li><li>computed有一个get和set方法，默认会走get方法，当数据发生变化时，会调用set方法</li></ul><p>watch：</p><ul><li>不支持缓存，数据变，直接会触发相应的操作</li><li>watch支持异步</li><li>监听的函数接口两个参数，一个newVal一个oldVal</li><li>当一个属性发生变化，需要执行对应的操作，一对多</li><li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数: immediate: 组件加载立即触发回调函数执行 deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用。</li></ul><p>总结：<br>除非不希望有缓存，一般都不会用方法调用<br>一般来说，需要依赖别的属性动态获取值的时候可以使用computed<br>对于监听到值的变化需要做异步操作或者开销较大的操作时候用watch</p><h5 id="class和style绑定"><a href="#class和style绑定" class="headerlink" title="class和style绑定"></a>class和style绑定</h5><p>因为他们都是属性，可以使用v-bind处理他们。</p><h6 id="class"><a href="#class" class="headerlink" title="class"></a>class</h6><ul><li>对象语法<br>可以传给v-bind:class一个对象，以动态切换class<pre><code class="hljs elixir">&lt;div <span class="hljs-symbol">:class=<span class="hljs-string">&quot;&#123;active: isActive&#125;&quot;</span>&gt;content&lt;/div&gt;</span>&lt;div <span class="hljs-symbol">:class=<span class="hljs-string">&quot;&#123;active: isActive, &#x27;test-danger&#x27;: hasError&#125;&quot;</span>&gt;content&lt;/div&gt;</span>最终会被渲染为：&lt;div class=<span class="hljs-string">&quot;active test-danger&quot;</span>&gt;content&lt;<span class="hljs-regexp">/div&gt;</span></code></pre>绑定的数据对象不必内联定义在模版里：<pre><code class="hljs elixir">&lt;div <span class="hljs-symbol">:class=<span class="hljs-string">&quot;classObject&quot;</span>&gt;content&lt;/div&gt;</span>data () &#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-symbol">classObject:</span> &#123;      <span class="hljs-symbol">active:</span> <span class="hljs-keyword">true</span>,      <span class="hljs-string">&#x27;text-danger&#x27;</span>: <span class="hljs-keyword">true</span>    &#125;  &#125;&#125;</code></pre>渲染的结果和上面的一样，也可以绑定一个返回对象的计算属性，这是一个常用且强大的模式<pre><code class="hljs kotlin">classObject: function () &#123;  <span class="hljs-keyword">return</span> &#123;    active: <span class="hljs-keyword">this</span>.isActive &amp;&amp; !<span class="hljs-keyword">this</span>.error,    <span class="hljs-string">&#x27;text-danger&#x27;</span>: <span class="hljs-keyword">this</span>.error &amp;&amp; <span class="hljs-keyword">this</span>.error.type === <span class="hljs-string">&#x27;fatal&#x27;</span>  &#125;&#125;</code></pre></li><li>数组语法<br>也可以把一个数组传给v-bind:class<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span>content<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  data () &#123;<span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">      activeClass: <span class="hljs-string">&#x27;active&#x27;</span>,</span><span class="javascript">      errorClass: <span class="hljs-string">&#x27;text-danger&#x27;</span></span>    &#125;  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>渲染为<pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;active text-danger&quot;</span>&gt;content&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>如果想根据条件切换class，可以使用表达式：<pre><code class="hljs elixir">&lt;div <span class="hljs-symbol">:class=<span class="hljs-string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;content&lt;/div&gt;</span></code></pre>始终添加errorClass，但是只有isActive为true时，才添加activeClass。</li></ul><p>不过，当有多个条件class时这样写有些繁琐，所以在数组语法中可以使用对象语法：</p><pre><code class="hljs elixir">&lt;div <span class="hljs-symbol">:class=<span class="hljs-string">&quot;[&#123;active: isActive&#125;, errorClass]&quot;</span>&gt;content&lt;/div&gt;</span></code></pre><h6 id="style"><a href="#style" class="headerlink" title="style"></a>style</h6><ul><li>对象语法<br>v-bind:style， CSS属性可以使用驼峰式(camelCase)或短横线分割(kebab-case)来命名<pre><code class="hljs elixir">&lt;div <span class="hljs-symbol">:style=<span class="hljs-string">&quot;&#123;color: activeColor, fontSize: fontSize + &#x27;px&#x27;&#125;&quot;</span>&gt;content&lt;/div&gt;</span></code></pre>直接绑定到一个样式对象通常更好，这样让模版更清晰<pre><code class="hljs elixir">&lt;div <span class="hljs-symbol">:style=<span class="hljs-string">&quot;styleObject&quot;</span>&gt;content&lt;/div&gt;</span><span class="hljs-keyword">return</span> &#123;  <span class="hljs-symbol">styleObject:</span> &#123;    <span class="hljs-symbol">color:</span> <span class="hljs-string">&#x27;red&#x27;</span>,    <span class="hljs-symbol">fontSize:</span> <span class="hljs-string">&#x27;30px&#x27;</span>  &#125;&#125;</code></pre></li><li>数组语法<br>v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上<pre><code class="hljs elixir"> &lt;div <span class="hljs-symbol">:style=<span class="hljs-string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;content&lt;/div&gt;</span>  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-symbol">baseStyles:</span> &#123;      <span class="hljs-symbol">color:</span> <span class="hljs-string">&#x27;red&#x27;</span>    &#125;  &#125;&#125;</code></pre><h5 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h5></li><li>v-if<pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;  A&lt;/<span class="hljs-keyword">div</span>&gt;&lt;<span class="hljs-keyword">div</span> v-<span class="hljs-keyword">else</span>-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;  B&lt;/<span class="hljs-keyword">div</span>&gt;&lt;<span class="hljs-keyword">div</span> v-<span class="hljs-keyword">else</span>-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;  C&lt;/<span class="hljs-keyword">div</span>&gt;&lt;<span class="hljs-keyword">div</span> v-<span class="hljs-keyword">else</span>&gt;  Not A<span class="hljs-regexp">/B/</span>C&lt;/<span class="hljs-keyword">div</span>&gt;````另一个用于条件判断的是v-show````&lt;<span class="hljs-keyword">div</span> v-show=<span class="hljs-string">&quot;ok&quot;</span>&gt;Hello&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>不同的是v-show的元素始终会被渲染并保留在DOM中，v-show只是简单的切换元素的css display</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow1&quot;</span>&gt;</span>显示1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow2&quot;</span>&gt;</span>显示2<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShow3&quot;</span>&gt;</span>显示3<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShow4&quot;</span>&gt;</span>显示4<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  data () &#123;<span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">      isShow1: <span class="hljs-literal">true</span>,</span><span class="javascript">      isShow2: <span class="hljs-literal">false</span>,</span><span class="javascript">      isShow3: <span class="hljs-literal">true</span>,</span><span class="javascript">      isShow4: <span class="hljs-literal">false</span></span>    &#125;  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>v-if的元素DOM元素销毁，v-show的元素只是给style加了个display状态</p><p>v-if vs v-show</p><ul><li>v-if是真正的条件渲染，因为他会确保在切换过程中条件块内的事件监听器和子组件适当的被销毁和重建</li><li>v-if是惰性的：如果在初始渲染时条件为假，则什么也不做一直到条件第一个为真时，才会开始渲染条件块</li><li>v-show不管初始条件是什么，元素总是会被渲染，并且只是简单的基于css进行切换</li><li>v-if有更高的切换开销，而v-show有更高的初始渲染开销。如果需要非常频繁的切换，则使用v-show较好，如果在运行条件很少改变，则使用v-if较好</li></ul><h6 id="v-if与v-for一起使用"><a href="#v-if与v-for一起使用" class="headerlink" title="v-if与v-for一起使用"></a>v-if与v-for一起使用</h6><p>不推荐两者同时使用, 可以将 v-if 置于外层元素或template元素上<br>当v-if与v-for一起使用时，v-for具有比v-if更有的优先级。</p><p>v-if 和 v-for 不要同时用在同一个元素上</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span></span><span class="xml">    v-for=&quot;user in users&quot;</span><span class="xml">    v-if=&quot;user.isActive&quot;</span><span class="xml">    :key=&quot;user.id&quot;&gt;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.name</span> &#125;&#125;</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></code></pre><pre><code class="hljs javascript">&lt;ul&gt;  &lt;li    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;user in activeUsers&quot;</span>    :key=<span class="hljs-string">&quot;user.id&quot;</span>  &gt;    &#123;&#123; user.name &#125;&#125;  &lt;/li&gt;&lt;/ul&gt;computed: &#123;  activeUsers: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.users.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">user</span>) </span>&#123;      <span class="hljs-keyword">return</span> user.isActive    &#125;)  &#125;&#125;</code></pre><p>2，避免渲染本应该隐藏的列表：将v-if移至容器元素上</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span></span><span class="xml">    v-for=&quot;user in users&quot;</span><span class="xml">    v-if=&quot;shouldShowUsers&quot;</span><span class="xml">    :key=&quot;user.id&quot;&gt;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.name</span> &#125;&#125;</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></code></pre><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;shouldShowUsers&quot;</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span></span><span class="xml">    v-for=&quot;user in users&quot;</span><span class="xml">    :key=&quot;user.id&quot;&gt;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.name</span> &#125;&#125;</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></code></pre><h5 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h5><ul><li>v-for里使用数组<br>v-for 使用item in items形式的语法，items是源数据数组，item是被迭代的数组元素的别名<br>在v-for块中，可以访问所有父作用域的属性，v-for支持一个可选的第二个参数，即当前项的索引<br>也可以用 of 代替 in作为分隔符，of更接近于js迭代器的语法<pre><code class="hljs awk">&lt;div v-fo<span class="hljs-string">r&quot;item of items&quot;</span>&gt;&lt;/div&gt;</code></pre></li><li>v-for里使用对象<pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;v-for-object&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name, index) in object&quot;</span>&gt;</span></span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">index</span>&#125;&#125;</span><span class="xml">. </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">name</span>&#125;&#125;</span><span class="xml">.</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">value</span> &#125;&#125;</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">new Vue(&#123;</span><span class="xml">  el: &#x27;#v-for-object&#x27;,</span><span class="xml">  data: &#123;</span><span class="xml">    object: &#123;</span><span class="xml">      title: &#x27;How to do lists in Vue&#x27;,</span><span class="xml">      author: &#x27;Jane Doe&#x27;,</span><span class="xml">      publishedAt: &#x27;2016-04-10&#x27;</span><span class="xml">    &#125;</span><span class="xml">  &#125;</span><span class="xml">&#125;)</span></code></pre>可以提供一个参数value, 也可以提供两个参数value, name。也可以提供3个参数value, name, index</li></ul><p>为了vue 能跟踪每个节点的位置，从而重用和重新排序现有元素，需要为每一项提供一个key属性</p><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item in items&quot;</span> :key=<span class="hljs-string">&quot;item.id&quot;</span>&gt;  内容&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre><p>key是vue识别节点的一个通用机制</p><h6 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h6><ul><li><p>变更方法<br>vue将被侦听的数组的变更方法进行了包裹，所以他们也将会触发视图更新，这些被包裹的方法包括：</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul></li><li><p>替换数组<br>变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如filter()、concat()、slice()。他们不会变更原始数组，而总是返回一个新数组。当使用非变更数据时，可以使用新数组替换旧数组</p></li></ul><p>有时，我们想显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据，这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组</p><pre><code class="hljs vim">&lt;li v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;n in evenNumbers&quot;</span>&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;dat<span class="hljs-variable">a:</span> &#123;  <span class="hljs-keyword">number</span><span class="hljs-variable">s:</span> [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]&#125;,computed: &#123;  evenNumber<span class="hljs-variable">s:</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> &#123;</span>    <span class="hljs-keyword">return</span> this.numbers.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(number)</span> &#123;</span>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">number</span> % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>    &#125;)  &#125;&#125;</code></pre><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>可以使用v-on监听DOM事件。</p><h6 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h6><ul><li>.stop</li><li>.prevent</li><li>.capture</li><li>.self</li><li>.once 点击事件只会触发一次</li><li>.passive<h4 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h4>可以使用v-model在表单input、textarea、select元素上创建双向数据绑定。v-model本质上是语法糖，他负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理<h6 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h6></li><li>.lazy<br>v-model在每次input事件触发后将输入框的值与数据进行同步，添加lazy修饰符，从而转为在change事件之后进行同步<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span></code></pre></li><li>.number<br>.number自动将用户输入的值转为数值类型<pre><code class="hljs vim">&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;number&quot;</span> v-model.<span class="hljs-keyword">number</span>=<span class="hljs-string">&quot;msg&quot;</span> &gt;</code></pre></li><li>.trim<br>过滤掉用户输入的首尾空白字符<pre><code class="hljs routeros">&lt;input v-model.<span class="hljs-attribute">trim</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</code></pre><h4 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h4><h6 id="data必须是一个函数"><a href="#data必须是一个函数" class="headerlink" title="data必须是一个函数"></a>data必须是一个函数</h6>一个组件的data选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：<pre><code class="hljs ada">data: <span class="hljs-keyword">function</span> <span class="hljs-title"></span>() &#123;  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span>    count: <span class="hljs-number">0</span>  &#125;&#125;</code></pre></li></ul><h6 id="父组件通过prop向子组件传递数据"><a href="#父组件通过prop向子组件传递数据" class="headerlink" title="父组件通过prop向子组件传递数据"></a>父组件通过prop向子组件传递数据</h6><p>方法1: 父传子，主要是通过v-bind绑定一个属性，在子组件里用props接受就可以了<br>方法2: 通过ref</p><pre><code class="hljs coffeescript">父组件&lt;HelloWorld ref=<span class="hljs-string">&quot;test1&quot;</span>/&gt;父组件调用子组件方法mounted () &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">this</span>.$refs.test1.test(<span class="hljs-string">&#x27;父组件的内容&#x27;</span>)  &#125;, <span class="hljs-number">1000</span>)&#125;子组件：methods: &#123;  test (v) &#123;    <span class="hljs-built_in">this</span>.value = v  &#125;&#125;</code></pre><h6 id="父组件监听子组件事件"><a href="#父组件监听子组件事件" class="headerlink" title="父组件监听子组件事件"></a>父组件监听子组件事件</h6><p>子传父，主要是在子组件里绑定一个方法，用$emit方法传递出去，$emit的第一个参数是父组件中定义的一个方法名称，第二个参数是要传的参数</p><pre><code class="hljs autoit">子组件&lt;button v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item in names&quot;</span> :key=<span class="hljs-string">&quot;item.id&quot;</span> <span class="hljs-symbol">@click</span>=<span class="hljs-string">&quot;itemClick(item)&quot;</span>&gt;&#123;&#123; item.name &#125;&#125; &lt;/button&gt;itemClick (v) &#123;    this.$emit(<span class="hljs-string">&#x27;parenClick&#x27;</span>, v)  &#125;父组件&lt;HelloWorld <span class="hljs-symbol">@parenClick</span>=<span class="hljs-string">&quot;getChild&quot;</span>/&gt;getChild (v) &#123;  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;接收到子组件的数据&#x27;</span>)  console.<span class="hljs-built_in">log</span>(v)&#125;</code></pre><h4 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h4><h6 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h6><p>在注册一个组件的时候，我们需要给他取一个名字。比如全局注册：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Vue</span><span class="hljs-selector-class">.component</span>(<span class="hljs-string">&#x27;my-component-name&#x27;</span>, &#123;&#125;)</code></pre><p>my-component-name就是组件名。强烈推荐自定义组件名(字母全小写，且必须包含一个连字符)</p><h6 id="组件名大小写"><a href="#组件名大小写" class="headerlink" title="组件名大小写"></a>组件名大小写</h6><p>定义组件名有两种方式</p><pre><code class="hljs less"><span class="hljs-selector-tag">1</span>, <span class="hljs-selector-tag">Vue</span><span class="hljs-selector-class">.component</span>(<span class="hljs-string">&#x27;my-component-name&#x27;</span>, &#123; <span class="hljs-comment">/* ... */</span> &#125;)<span class="hljs-selector-tag">2</span>, <span class="hljs-selector-tag">Vue</span><span class="hljs-selector-class">.component</span>(<span class="hljs-string">&#x27;MyComponentName&#x27;</span>, &#123; <span class="hljs-comment">/* ... */</span> &#125;)</code></pre><p>当使用首字母大写命名时，引入自定义元素时两种命名方法都可以使用。也就是说my-component-name标签和MyComponentName标签。</p><p>当使用连字符命名时，必须使用my-component-name标签引入</p><h6 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h6><p>到目前为止，我们只用过 Vue.component 来创建组件：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Vue</span><span class="hljs-selector-class">.component</span>(<span class="hljs-string">&#x27;my-component-name&#x27;</span>, &#123;  <span class="hljs-comment">// ... 选项 ...</span>&#125;)</code></pre><p>这些组件是全局注册的。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (new Vue) 的模板中。比如：</p><pre><code class="hljs javascript">Vue.component(<span class="hljs-string">&#x27;component-a&#x27;</span>, &#123; <span class="hljs-comment">/* ... */</span> &#125;)Vue.component(<span class="hljs-string">&#x27;component-b&#x27;</span>, &#123; <span class="hljs-comment">/* ... */</span> &#125;)Vue.component(<span class="hljs-string">&#x27;component-c&#x27;</span>, &#123; <span class="hljs-comment">/* ... */</span> &#125;)<span class="hljs-keyword">new</span> Vue(&#123; <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span> &#125;)&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;  &lt;component-a&gt;&lt;/component-a&gt;  &lt;component-b&gt;&lt;/component-b&gt;  &lt;component-c&gt;&lt;/component-c&gt;&lt;/div&gt;</code></pre><p>在所有子组件中也是如此，也就是说这三个组件在各自内部也都可以相互使用。</p><h6 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h6><p>全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。</p><p>在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件：</p><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> ComponentA = &#123;&#125;<span class="hljs-keyword">var</span> ComponentB = &#123;&#125;<span class="hljs-keyword">var</span> ComponentC = &#123;&#125;</code></pre><p>然后在 components 引入即可</p><pre><code class="hljs clean">components: &#123;  <span class="hljs-string">&#x27;component-a&#x27;</span>: ComponentA,  <span class="hljs-string">&#x27;component-b&#x27;</span>: ComponentB,  <span class="hljs-string">&#x27;component-c&#x27;</span>: ComponentC&#125;````### Prop###### Prop的大小写html中的属性名大小写是不敏感的，所以浏览器会把所有大写字符串解释为小写字符。</code></pre><p>Vue.component(‘blog-post’, {<br>  // 在 JavaScript 中是 camelCase 的<br>  props: [‘postTitle’],<br>  template: ‘<h3></h3>‘<br>})</p><pre><code class="hljs xml">```<span class="hljs-comment">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">post-title</span>=<span class="hljs-string">&quot;hello!&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span></code></pre><p>重申一次，如果使用模版字符串，这个限制就不存在了</p><h6 id="Prop类型"><a href="#Prop类型" class="headerlink" title="Prop类型"></a>Prop类型</h6><p>1，字符串数组形式的Prop</p><pre><code class="hljs css"><span class="hljs-selector-tag">props</span>: <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;likes&#x27;</span>, <span class="hljs-string">&#x27;author&#x27;</span>, <span class="hljs-string">&#x27;userId&#x27;</span>]</span></code></pre><p>2，通常需要每个prop都有指定的值类型。就可以使用对象形式列出prop</p><pre><code class="hljs dts"><span class="hljs-symbol">props:</span> &#123;<span class="hljs-symbol">  title:</span> String,<span class="hljs-symbol">  likes:</span> Number,<span class="hljs-symbol">  author:</span> Object,<span class="hljs-symbol">  userId:</span> Number&#125;</code></pre><p>类型可以是</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Date</li><li>Function</li><li>Symbol<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4>在2.6.0中，具名插槽和作用域插槽引入了一个新的统一的语法v-slot指令，他取代了slot和slot-scope这两个目前已经被废弃但被移出且仍在文档中的属性。新语法的由来可查看这份<a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md">RFC</a></li></ul><p>插槽内可以包含任何模版代码</p><h6 id="插槽内容"><a href="#插槽内容" class="headerlink" title="插槽内容"></a>插槽内容</h6><p>Vue 实现了一套内容分发的 API，将 <slot> 元素作为承载分发内容的出口。</p><p>它允许你像这样合成组件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span>  Your Profile<span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span></code></pre><p>然后在navigation-link的模版中可能会写为</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span><span class="hljs-tag">  <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-link&quot;</span></span><span class="hljs-tag">&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>当组件渲染的时候，<slot></slot> 将会被替换为“Your Profile”，插槽内可以包含任何模板代码，包括 HTML：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 添加一个 Font Awesome 图标 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  Your Profile<span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span>甚至其他的组件<span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 添加一个图标的组件 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">font-awesome-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font-awesome-icon</span>&gt;</span>  Your Profile<span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span></code></pre><p>如果navigation-link组件的 template 中没有包含一个 slot组件，则该组件起始标签和结束标签之间的任何内容都会被抛弃。</p><h6 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h6><p>有时我们需要多个插槽。例如对于一个带有如下模板的 base-layout 组件：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 我们希望把页头放这里 --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>对于这样的情况，slot 元素有一个特殊的 attribute：name。这个 attribute 可以用来定义额外的插槽</p><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">container</span>&quot;&gt;  &lt;<span class="hljs-symbol">header</span>&gt;    &lt;<span class="hljs-symbol">slot</span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">header</span>&quot;&gt;&lt;/<span class="hljs-symbol">slot</span>&gt;  &lt;/<span class="hljs-symbol">header</span>&gt;  &lt;<span class="hljs-symbol">main</span>&gt;    &lt;<span class="hljs-symbol">slot</span>&gt;&lt;/<span class="hljs-symbol">slot</span>&gt;  &lt;/<span class="hljs-symbol">main</span>&gt;  &lt;<span class="hljs-symbol">footer</span>&gt;    &lt;<span class="hljs-symbol">slot</span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">footer</span>&quot;&gt;&lt;/<span class="hljs-symbol">slot</span>&gt;  &lt;/<span class="hljs-symbol">footer</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre><p>一个不带 name 的 slot 出口会带有隐含的名字“default”。<br>在向具名插槽提供内容的时候，我们可以在一个 template 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span></code></pre><p>现在 template 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 v-slot 的 template 中的内容都会被视为默认插槽的内容。</p><p>然而，如果你希望更明确一些，仍然可以在一个 template 中包裹默认插槽的内容：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span></code></pre><p>任何一种写法都会渲染出：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>注意 v-slot 只能添加在 template标签上 (只有一种例外情况)，这一点和已经废弃的 slot attribute 不同</p><h6 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h6><p>有时让插槽内容能够访问子组件中才有的数据是很有用的。例如，设想一个带有如下模板的 current-user&gt; 组件：</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.lastName</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></code></pre><p>我们可能想换掉备用内容，用名而非姓来显示。如下：</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span></span><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.firstName</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></span></code></pre><p>然而上述代码不会正常工作，因为只有 current-user&gt; 组件可以访问到 user 而我们提供的内容是在父级渲染的。</p><p>为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 slot&gt; 元素的一个 attribute 绑定上去：</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.lastName</span> &#125;&#125;</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></code></pre><p>绑定在 slot&gt; 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字：</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span></span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">slotProps.user.firstName</span> &#125;&#125;</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></span></code></pre><p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 slotProps，但你也可以使用任意你喜欢的名字。</p><h6 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h6><p>动态指令参数也可以用在 v-slot 上，来定义动态的插槽名：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:</span>[<span class="hljs-attr">dynamicSlotName</span>]&gt;</span>    ...  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre><h6 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h6><p>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">header</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span></code></pre><p>然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-comment">&lt;!-- 这样会触发一个警告 --&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> #=<span class="hljs-string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.firstName</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></span></code></pre><p>如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">&quot;&#123; user &#125;&quot;</span>&gt;</span></span><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.firstName</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></span></code></pre><h4 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件 &amp; 异步组件"></a>动态组件 &amp; 异步组件</h4><h6 id="在动态组件上使用keep-alive"><a href="#在动态组件上使用keep-alive" class="headerlink" title="在动态组件上使用keep-alive"></a>在动态组件上使用keep-alive</h6><p>keep-alive是Vue提供的一个抽象组件，主要用于保留组件状态或避免重新渲染。</p><p>我们之前曾经在一个多标签的界面中使用 is attribute 来切换不同的组件：</p><pre><code class="hljs vhdl">&lt;<span class="hljs-keyword">component</span> v-bind:<span class="hljs-keyword">is</span>=<span class="hljs-string">&quot;currentTabComponent&quot;</span>&gt;&lt;/<span class="hljs-keyword">component</span>&gt;</code></pre><p>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题</p><p>你会注意到，如果你选择了一篇文章，切换到 Archive 标签，然后再切换回 Posts，是不会继续展示你之前选择的文章的。这是因为你每次切换新标签的时候，Vue 都创建了一个新的 currentTabComponent 实例。</p><p>重新创建动态组件的行为通常是非常有用的，但是在这个案例中，我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，我们可以用一个 keep-alive&gt; 元素将其动态组件包裹起来。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 失活的组件将会被缓存！--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">v-bind:is</span>=<span class="hljs-string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></code></pre><p>现在这个 Posts 标签保持了它的状态 (被选中的文章) 甚至当它未被渲染时也是如此</p><h4 id="Vue常见面试题"><a href="#Vue常见面试题" class="headerlink" title="Vue常见面试题"></a>Vue常见面试题</h4><h6 id="1，vue数据双向绑定"><a href="#1，vue数据双向绑定" class="headerlink" title="1，vue数据双向绑定"></a>1，vue数据双向绑定</h6><p>Vue数据双向绑定主要采用数据劫持 结合 发布 - 订阅的方式，通过Object.defineProperty()的set和get方法，在数据变动时发布消息给订阅者触发监听。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wangyaru&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> obj = &#123;&#125;</span><span class="javascript">    <span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;</span><span class="javascript">        get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">return</span> obj</span>        &#125;,<span class="javascript">        set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>) </span>&#123;</span><span class="javascript">            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;wangyaru&#x27;</span>).value = newVal</span><span class="javascript">            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;Content&#x27;</span>).innerHTML = newVal</span>        &#125;    &#125;)<span class="javascript">    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;wangyaru&#x27;</span>).onkeyup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span>        obj.name = e.target.value    &#125;<span class="javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">        obj.name = <span class="hljs-string">&#x27;9999&#x27;</span></span>    &#125;, 1000)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h5 id="2，-nextTick"><a href="#2，-nextTick" class="headerlink" title="2，$nextTick"></a>2，$nextTick</h5><p>$nextTick是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM。</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;msg1&quot;</span>&gt;</span>msg1: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg1</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;msg2&quot;</span>&gt;</span>msg2: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg2</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;msg3&quot;</span>&gt;</span>msg3: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg3</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeMsg&quot;</span>&gt;</span></span><span class="xml">      change the msg</span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">HelloWorld</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;</span><span class="xml">export default &#123;</span><span class="xml">  components: &#123;</span><span class="xml">    HelloWorld</span><span class="xml">  &#125;,</span><span class="xml">  data () &#123;</span><span class="xml">    return &#123;</span><span class="xml">      msg: &#x27;Hello Vue&#x27;,</span><span class="xml">      msg1: &#x27;&#x27;,</span><span class="xml">      msg2: &#x27;&#x27;,</span><span class="xml">      msg3: &#x27;&#x27;,</span><span class="xml">    &#125;</span><span class="xml">  &#125;,</span><span class="xml">  methods: &#123;</span><span class="xml">    changeMsg () &#123;</span><span class="xml">      this.msg = &#x27;Hello World&#x27;</span><span class="xml">      this.msg1 = this.$refs.msg.innerHTML</span><span class="xml">      this.$nextTick(() =&gt; &#123;</span><span class="xml">        this.msg2 = this.$refs.msg.innerHTML</span><span class="xml">      &#125;)</span><span class="xml">      this.msg3 = this.$refs.msg.innerHTML</span><span class="xml">    &#125;</span><span class="xml">  &#125;</span><span class="xml">&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><p>点击按钮之后，界面如下<br>Hello World<br>msg1: Hello Vue<br>msg2: Hello World<br>msg3: Hello Vue</p><p>msg1、msg3显示的还是变换之前的，而msg2显示的是变换之后的，这是因为Vue中DOM更新是异步的</p><h5 id="3，如何给vue定义全局方法"><a href="#3，如何给vue定义全局方法" class="headerlink" title="3，如何给vue定义全局方法"></a>3，如何给vue定义全局方法</h5><p>挂载到vue的原型上： Vue.prototype.methodsName = function () {}<br>使用mixin: Vue.use(mixins)</p><h5 id="4-描述一下封装vue组件的过程"><a href="#4-描述一下封装vue组件的过程" class="headerlink" title="4, 描述一下封装vue组件的过程"></a>4, 描述一下封装vue组件的过程</h5><p>组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了传统项目开发的效率低、难维护、复用性等问题。</p><p>过程：使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册一个组件。子组件需要数据，可以在props接受定义。而子组件修改好数据后，可以通过$emit方法把数据传递给父组件。</p><h5 id="5，npm发布插件"><a href="#5，npm发布插件" class="headerlink" title="5，npm发布插件"></a>5，npm发布插件</h5><p>npm adduser –registry <a href="http://registry.npmjs.org/">http://registry.npmjs.org</a> 添加npm用户<br>npm login 登录<br>npm whoami 查看个人信息<br>npm publish –registry <a href="http://registry.npmjs.org/">http://registry.npmjs.org</a>  发布<br><a href="https://www.npmjs.com/">https://www.npmjs.com/</a> + 插件名   查看发布成功<br>npm unpublish 包名@版本号  删除插件</p><h5 id="6-v-model-的原理"><a href="#6-v-model-的原理" class="headerlink" title="6, v-model 的原理"></a>6, v-model 的原理</h5><p>v-model只是语法糖而已</p><p>语法糖： 也叫糖衣语法，主要是方便程序猿使用，通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会<br>1， v-model在input元素上</p><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attribute">v-model</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> v-bind:<span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;msg&quot;</span> v-on:<span class="hljs-attribute">input</span>=<span class="hljs-string">&quot;msg = <span class="hljs-variable">$event</span>.target.value&quot;</span>&gt;</code></pre><p>第一行是第二行的语法糖</p><p>第二行代码还可以简写</p><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> :<span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;msg&quot;</span> @<span class="hljs-attribute">input</span>=<span class="hljs-string">&quot;msg = <span class="hljs-variable">$event</span>.target.value&quot;</span>&gt;</code></pre><h5 id="7-vue响应式原理Object-defineProperty缺点"><a href="#7-vue响应式原理Object-defineProperty缺点" class="headerlink" title="7, vue响应式原理Object.defineProperty缺点"></a>7, vue响应式原理Object.defineProperty缺点</h5><pre><code class="hljs javascript"><span class="hljs-comment">// 这是将要被劫持的对象</span> <span class="hljs-keyword">const</span> data = &#123;     name: <span class="hljs-string">&#x27;&#x27;</span> &#125; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params">name</span>) </span>&#123;     <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;xiaowang&#x27;</span>) &#123;         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;wangyaru&#x27;</span>)     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;xiaoma&#x27;</span>) &#123;         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ergouzi&#x27;</span>)     &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;大兄弟&#x27;</span>)     &#125; &#125; <span class="hljs-comment">// 遍历对象，对其属性进行劫持</span> <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;     <span class="hljs-built_in">Object</span>.defineProperty(data, key, &#123;         enumerable: <span class="hljs-literal">true</span>,         configurable: <span class="hljs-literal">true</span>,         get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;             <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;get&#x27;</span>)         &#125;,         set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>) </span>&#123;             say(newVal)         &#125;     &#125;) &#125;) data.name = <span class="hljs-string">&#x27;xiaowang&#x27;</span></code></pre><p>虽然Object.defineProperty通过为属性设置getter/setter能够完成数据的响应式，但是有缺陷<br>1，无法检测到对象属性的新增和删除</p><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">obj</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">arr</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="xml">data()&#123;</span><span class="xml">  return &#123;</span><span class="xml">      obj:&#123;</span><span class="xml">          a:2</span><span class="xml">      &#125;</span><span class="xml">  &#125;</span><span class="xml">&#125;,</span><span class="xml">mounted () &#123;</span><span class="xml">  this.obj.b = 222</span><span class="xml">&#125;,</span><span class="xml"><span class="hljs-comment">&lt;!-- obj显示结果 --&gt;</span></span><span class="xml">//obj:&#123; &quot;a&quot;: 2 &#125;</span></code></pre><p>解决办法<br>1，增加属性</p><pre><code class="hljs kotlin">方法<span class="hljs-number">1</span>: 可以在mounted方法里加<span class="hljs-keyword">this</span>.$forceUpdate()强制刷新方法<span class="hljs-number">2</span>: mounted() &#123;  <span class="hljs-keyword">this</span>.obj = Object.assign(&#123;&#125;, <span class="hljs-keyword">this</span>.obj, &#123;b: <span class="hljs-number">100</span>, c: <span class="hljs-number">200</span>&#125;)  <span class="hljs-keyword">this</span>.$<span class="hljs-keyword">set</span>(<span class="hljs-keyword">this</span>.obj, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">100</span>)  <span class="hljs-keyword">this</span>.obj = &#123;...<span class="hljs-keyword">this</span>.obj, ...&#123;b: <span class="hljs-number">3</span>, c: <span class="hljs-number">2</span>&#125;&#125;&#125;</code></pre><p>数组类似<br>2，删除属性</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vue</span>.</span></span>delete(obj, propertyName/index)vue.<span class="hljs-constructor">$delete(<span class="hljs-params">obj</span>, <span class="hljs-params">propertyName</span><span class="hljs-operator">/</span><span class="hljs-params">index</span>)</span></code></pre><p>2，缺陷2 - 无法监听数组变化<br>vue实现响应式时，把无法监听数组的情况通过重写数组的部分方法来实现响应式，但是只局限于以下7中方法：push pop shift unshift splice sort reverse</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;arr&#125;</span><span class="xml">&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="xml">data()</span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable">    return &#123;</span><span class="hljs-template-variable">        arr:[1,2]</span><span class="hljs-template-variable">    &#125;</span><span class="xml">&#125;,</span><span class="xml">mounted () </span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable">    this.arr[0]= 3333</span><span class="hljs-template-variable">&#125;</span><span class="xml">,</span><span class="xml"><span class="hljs-comment">&lt;!-- arr显示结果 --&gt;</span></span><span class="xml">arr:[ 1, 2 ]</span></code></pre><h5 id="8-v-if-v-show区别"><a href="#8-v-if-v-show区别" class="headerlink" title="8, v-if v-show区别"></a>8, v-if v-show区别</h5><p>v-if的原理是根据判断条件来动态增删DOM元素。<br>v-show是根据判断条件来动态进行元素显示隐藏<br>频繁的增删DOM会影响页面加载速度和性能，不推荐使用v-if<br>只有v-if能和v-else进行分支判断，如果出现多种条件场景的情况下，可以使用v-if来进行判断</p><h5 id="9，mounted和created区别"><a href="#9，mounted和created区别" class="headerlink" title="9，mounted和created区别"></a>9，mounted和created区别</h5><p>什么是生命周期： vue的实例或组件从创建到销毁的过程<br>mounted和created区别：<br>created视图中的html并没有渲染出来，此时如果直接操作html的dom节点，一定找不到相关的元素<br>mounted的时候html已经渲染出来，可以直接操作dom节点(已完成html虚拟化，创建了el节点，可以操作DOM了)</p><h5 id="10，keep-alive"><a href="#10，keep-alive" class="headerlink" title="10，keep-alive"></a>10，keep-alive</h5><p>keep-alive是Vue提供的一个抽象组件，主要用于保留组件状态或避免组件重新渲染。</p><h5 id="11，vuex"><a href="#11，vuex" class="headerlink" title="11，vuex"></a>11，vuex</h5><p>vuex是一个状态管理器，多个组件共享状态的时候使用vuex,或者是跨组件传递数据时使用vuex</p><p>vuex的流程：<br>页面通过mapAction异步提交事件到action，action通过commit把对应参数同步提交到mutation，mutation会修改state中对应的值。最后通过getter把对应的值跑出去，在页面的计算属性中，通过mapGetter来动态获取state中的值</p><p>vuex属性：有5种<br>state、getter、mutation、action、module(就是mapAction)<br>1，state: vuex的基本数据，用来储存一些数据或者说是用来存储一些状态值<br>2，getter：从基本数据(state)派生的数据，相当于state的计算属性<br>3，mutation: 提交更新数据的方法，必须是同步的，每个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)，回调函数就是我们进行状态更改的地方，并且他会接受state作为第一个参数，提交载荷作为第二个参数<br>4，action: action提交的是mutation，而不是直接变更状态， action可以包含任意异步操作<br>5，modules: 模块化vuex，可以让每一个模块都有自己的state、getter、mutation、action，使得结构清晰，方便管理</p><pre><code class="hljs pf"><span class="hljs-keyword">const</span> store = new Vuex.Store(&#123;  <span class="hljs-keyword">state</span>: &#123;    count: <span class="hljs-number">0</span>  &#125;,  mutations: &#123;    increment (<span class="hljs-keyword">state</span>) &#123;      <span class="hljs-keyword">state</span>.count++    &#125;  &#125;,  actions: &#123;    increment (context) &#123;      context.commit(&#x27;increment&#x27;)    &#125;  &#125;&#125;)</code></pre><pre><code class="hljs pf"><span class="hljs-keyword">const</span> <span class="hljs-keyword">user</span> = &#123;  <span class="hljs-keyword">state</span>:&#123;      <span class="hljs-literal">self</span>: null,      token: &#x27;&#x27;,  &#125;,  mutations:&#123;      SET_SELF: (<span class="hljs-keyword">state</span>, <span class="hljs-literal">self</span>) =&gt; &#123;           <span class="hljs-keyword">state</span>.<span class="hljs-literal">self</span> = <span class="hljs-literal">self</span>       &#125;,       SET_TOKEN: (<span class="hljs-keyword">state</span>, token) =&gt; &#123;           <span class="hljs-keyword">state</span>.token = token       &#125;  &#125;,  actions:&#123;       login (&#123; commit &#125;, res) &#123;            commit(&#x27;SET_SELF&#x27;, res.<span class="hljs-literal">self</span>)            commit(&#x27;SET_TOKEN&#x27;, res.token)      &#125;   &#125;&#125;export <span class="hljs-keyword">default</span> <span class="hljs-keyword">user</span></code></pre><p>使用下面这两种方法存储数据：</p><p>　　dispatch：异步操作，写法： this.$store.dispatch(‘actions方法名’,值)</p><p>　　commit：同步操作，写法：this.$store.commit(‘mutations方法名’,值)</p><p>1,state<br>用来存储一些数据或者状态值, state在使用的时候一般被挂载到子组件的computed计算属性上，这样有利于state的值发生改变的时候及时响应给子组件，如果你用data去接收$store.state,当然可以接收到值,但由于这只是一个简单的赋值操作,因此state中的状态改变的时候不能被vue中的data监听到,当然你也可以通过watch $store去解决这个问题</p><pre><code class="hljs pf">//<span class="hljs-keyword">state</span>.jslet <span class="hljs-keyword">state</span> = &#123;  count: <span class="hljs-number">1</span>,  name: &#x27;dkr&#x27;,  sex: &#x27;男&#x27;,  <span class="hljs-keyword">from</span>: &#x27;china&#x27;&#125;export <span class="hljs-keyword">default</span> <span class="hljs-keyword">state</span></code></pre><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decrement&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">count</span>&#125;&#125;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">dataCount</span>&#125;&#125;</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">export default &#123;</span><span class="xml">  data () &#123;</span><span class="xml">    return &#123;</span><span class="xml">      dataCount: this.$store.state.count //用data接收</span><span class="xml">    &#125;</span><span class="xml">  &#125;,</span><span class="xml">  computed:&#123;</span><span class="xml">    count()&#123;</span><span class="xml">      return this.$store.state.count //用computed接收</span><span class="xml">    &#125;</span><span class="xml">  &#125;</span><span class="xml">  methods: &#123;</span><span class="xml">    increment () &#123;</span><span class="xml">      this.$store.commit(&#x27;increment&#x27;)</span><span class="xml">    &#125;,</span><span class="xml">    decrement () &#123;</span><span class="xml">      this.$store.commit(&#x27;decrement&#x27;)</span><span class="xml">    &#125;</span><span class="xml">  &#125;</span><span class="xml">&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><p>用data接收的值不能及时响应更新，用computedu就可以。<br>2，mapState<br>2，mapState是state的辅助函数，即mapState是state的语法糖。<br>作用：当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性<br>在使用mapState之前,要导入这个辅助函数.</p><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; mapState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></code></pre><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decrement&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">count</span>&#125;&#125;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">dataCount</span>&#125;&#125;</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">sex</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">from</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">myCmpted</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">import &#123; mapState &#125; from &#x27;vuex&#x27;</span><span class="xml">export default &#123;</span><span class="xml">  data () &#123;</span><span class="xml">    return &#123;</span><span class="xml">      str: &#x27;国籍&#x27;,</span><span class="xml">      dataCount: this.$store.state.count</span><span class="xml">    &#125;</span><span class="xml">  &#125;,</span><span class="xml">  computed: mapState(&#123;</span><span class="xml">    count: &#x27;count&#x27;, // 第一种写法</span><span class="xml">    sex: (state) =&gt; state.sex, // 第二种写法</span><span class="xml">    from: function (state) &#123; // 用普通函数this指向vue实例,要注意</span><span class="xml">      return this.str + &#x27;:&#x27; + state.from</span><span class="xml">    &#125;,</span><span class="xml">    // 注意下面的写法看起来和上面相同,事实上箭头函数的this指针并没有指向vue实例,因此不要滥用箭头函数</span><span class="xml">    // from: (state) =&gt; this.str + &#x27;:&#x27; + state.from</span><span class="xml">    myCmpted: function () &#123;</span><span class="xml">      // 这里不需要state,测试一下computed的原有用法</span><span class="xml">      return &#x27;测试&#x27; + this.str</span><span class="xml">    &#125;</span><span class="xml">  &#125;),</span><span class="xml">  methods: &#123;</span><span class="xml">    increment () &#123;</span><span class="xml">      this.$store.commit(&#x27;increment&#x27;)</span><span class="xml">    &#125;,</span><span class="xml">    decrement () &#123;</span><span class="xml">      this.$store.commit(&#x27;decrement&#x27;)</span><span class="xml">    &#125;</span><span class="xml">  &#125;,</span><span class="xml">  created () &#123;</span><span class="xml">    // 写个定时器，发现computed依旧保持了只要内部有相关属性发生改变不管是当前实例data中的改变，还是vuex中的值改变都会触发dom和值更新</span><span class="xml">    setTimeout(() =&gt; &#123;</span><span class="xml">      this.str = &#x27;国家&#x27;</span><span class="xml">    &#125;, 1000)</span><span class="xml">  &#125;</span><span class="xml">&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><p>3, …mapState<br>…mapState并不是mapState的扩展,而是…对象展开符的扩展.当然如果你把他用在这里会发现他能使得代码看起来变得,更加符合常规逻辑了,为什么这么说,你等下就会知道了.</p><p>  首先,来回顾一下…对象展开符在数组中的表现,这在ES6语法学习分类里有相关说明,如果有兴趣可以关注我的ES6分类中的文章.</p><pre><code class="hljs angelscript">let arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]console.log(...arr) <span class="hljs-comment">//1,2,3</span></code></pre><p>然后来看一个例子.</p><pre><code class="hljs pf">let MapState = mapState(&#123;  count: &#x27;count&#x27;,  sex: (<span class="hljs-keyword">state</span>) =&gt; <span class="hljs-keyword">state</span>.sex&#125;)let json = &#123;  &#x27;a&#x27;: &#x27;我是json自带的&#x27;,  ...MapState&#125;console.<span class="hljs-keyword">log</span>(json)</code></pre><p>这里的json可以成功将mapState return的json格式,和json自带的a属性成功融合成一个新的对象.你可以将这个称为对象混合<br>这样,你就可以自由的使用mapState了.</p><pre><code class="hljs lasso"><span class="hljs-comment">//之前的computed</span>computed:&#123;    fn1()&#123; <span class="hljs-keyword">return</span> <span class="hljs-params">...</span>&#125;,    fn2()&#123; <span class="hljs-keyword">return</span> <span class="hljs-params">...</span>&#125;,    fn3()&#123; <span class="hljs-keyword">return</span> <span class="hljs-params">...</span>&#125;    <span class="hljs-params">...</span><span class="hljs-params">...</span>..&#125;<span class="hljs-comment">//引入mapState辅助函数之后</span> computed:&#123;    <span class="hljs-comment">//原来的继续保留</span>    fn1()&#123; <span class="hljs-keyword">return</span> <span class="hljs-params">...</span>&#125;,    fn2()&#123; <span class="hljs-keyword">return</span> <span class="hljs-params">...</span>&#125;,    fn3()&#123; <span class="hljs-keyword">return</span> <span class="hljs-params">...</span>&#125;    <span class="hljs-params">...</span><span class="hljs-params">...</span>    <span class="hljs-comment">//再维护vuex</span>    <span class="hljs-params">...</span>mapState(&#123;  <span class="hljs-comment">//这里的...不是省略号了,是对象扩展符</span>        count:<span class="hljs-string">&#x27;count&#x27;</span>    &#125;)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/2021/05/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/05/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>面向对象(Object-Oriented, OO)的语言的标志就是他们都有类的概念。通过类可以创建任意多个具有相同属性和方法的对象。</p><h5 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h5><p>早期的开发人员创建自定义对象最简单的方式就是创建一个Object的实例，然后再为他添加属性和方法：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()person.name = <span class="hljs-string">&#x27;张三&#x27;</span>person.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)&#125;</code></pre><p>几年后，创建对象最简单的方式是对象字面量：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;  name: <span class="hljs-string">&#x27;张三&#x27;</span>,  sayName:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)  &#125;&#125;</code></pre><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><p>ESMAScript有两种属性：数据属性、访问器属性</p><blockquote><p>1，数据属性<br>数据属性有4个描述其行为的特性：</p></blockquote><ul><li>[[configurable]]：表示是否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性</li><li>[[enumberable]]:表示能否通过for..in循环返回属性</li><li>[[writeable]]: 表示能否修改属性的值</li><li>[[value]]: 包括这个属性的数据值，读取属性值的时候，从这个位置读，写入属性值的时候，把新值保存在这个位置</li></ul><p>要修改属性默认的特性，必须使用Object.defineProperty()方法，这个方法接受3个参数：属性所在的对象、属性的名字、描述符对象。其中描述符对象的属性必须是：configurable、enumberable、writeable、value</p><p>通过Object.defineProperty()创建一个新的属性的时候，如果configurable、enumberable、writeable这三个参数不指定，默认值都是false</p><pre><code class="hljs pgsql">var person = &#123;&#125;<span class="hljs-keyword">Object</span>.defineProperty(person, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;    writable: <span class="hljs-keyword">false</span>,    <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;张三&#x27;</span>&#125;)console.log(person.name)  // 张三person.name = <span class="hljs-string">&#x27;李四&#x27;</span>console.log(person.name)  // 张三</code></pre><p>以上代码，创建了一个名为name的属性，他的值”张三”是只读的。</p><pre><code class="hljs pgsql">var person = &#123;&#125;<span class="hljs-keyword">Object</span>.defineProperty(person, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;    configurable: <span class="hljs-keyword">true</span>,    <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;张三&#x27;</span>&#125;)console.log(person.name)  // 张三<span class="hljs-keyword">delete</span> person.nameconsole.log(person.name)  // undefined</code></pre><p>以上代码，把configurable设为false, 表示不能从对象中删除属性。</p><blockquote><p>2, 访问器属性</p></blockquote><p>访问器属性不包含数据值。包含一对getter和setter函数；</p><p>getter: 在读取访问器属性的时候，会调用getter函数，这个函数负责返回有效的值。</p><p>setter: 在写入访问器属性的时候，会调用setter函数并传入新值，这个函数负责决定如何处理数据</p><p>访问器属性有以下4个特性：</p><ul><li><p>[[configurable]]: 表示能否删除属性从而重新定义属性</p></li><li><p>[[enumerable]]: 表示能否通过for..in循环返回属性</p></li><li><p>[[Get]]: 在读取属性时调用的函数，默认值是undefined</p></li><li><p>[[Set]]: 在写入属性时调用的函数，默认值是undefined<br>访问器属性不能直接定义，必须使用Object.defineProperty()定义：</p><pre><code class="hljs haxe">const book = &#123;  _year: <span class="hljs-type">2020</span>,  edition: <span class="hljs-type">1</span><span class="hljs-type"></span>&#125;Object.defineProperty(book, <span class="hljs-string">&#x27;year&#x27;</span>, &#123;  <span class="hljs-keyword">get</span>: <span class="hljs-type">function</span>() &#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._year  &#125;,  <span class="hljs-keyword">set</span>: <span class="hljs-type">function</span>(<span class="hljs-keyword">new</span><span class="hljs-type">Val</span>) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Val</span> &gt; <span class="hljs-number">2020</span>) &#123;          <span class="hljs-built_in">this</span>._year = <span class="hljs-keyword">new</span><span class="hljs-type">Val</span><span class="hljs-type"></span>          <span class="hljs-built_in">this</span>.edition += <span class="hljs-keyword">new</span><span class="hljs-type">Val</span> - <span class="hljs-number">2020</span>      &#125;  &#125;&#125;)book.year = <span class="hljs-number">2023</span>console.log(book.edition)  <span class="hljs-comment">// 4</span></code></pre><p>以上代码创建了一个book对象，并给定两个默认属性：_year、edition，_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。</p><h4 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h4><p>因为对象定义多个属性的可能性很大，ECMAScript又定义了一个Object.defineProperties()方法，可以通过描述符一次定义多个属性。这个方法接受两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要调价或修改的属性–对应：</p><pre><code class="hljs yaml"><span class="hljs-string">const</span> <span class="hljs-string">book</span> <span class="hljs-string">=</span> &#123;&#125;<span class="hljs-string">Object.defineProperties(book,</span> &#123;    <span class="hljs-attr">_year:</span> &#123;        <span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span>,        <span class="hljs-attr">value:</span> <span class="hljs-number">2020</span>    &#125;,    <span class="hljs-attr">edition:</span> &#123;        <span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span>,        <span class="hljs-attr">value:</span> <span class="hljs-number">1</span>    &#125;,    <span class="hljs-attr">year:</span> &#123;        <span class="hljs-attr">get:</span> <span class="hljs-string">function()</span> &#123;            <span class="hljs-string">return</span> <span class="hljs-string">this._year</span>        &#125;,        <span class="hljs-attr">set:</span> <span class="hljs-string">function(newVal)</span> &#123;            <span class="hljs-string">if</span> <span class="hljs-string">(newVal</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">2020</span><span class="hljs-string">)</span> &#123;                <span class="hljs-string">this._year</span> <span class="hljs-string">=</span> <span class="hljs-string">newVal</span>                <span class="hljs-string">this.edition</span> <span class="hljs-string">+=</span> <span class="hljs-string">newVal</span> <span class="hljs-bullet">-</span> <span class="hljs-number">2020</span>            &#125;        &#125;    &#125;&#125;<span class="hljs-string">)</span><span class="hljs-string">book.year</span> <span class="hljs-string">=</span> <span class="hljs-number">2028</span><span class="hljs-string">console.log(book.edition)</span>  <span class="hljs-string">//</span> <span class="hljs-number">9</span></code></pre><p>以上代码book对象上定义了两个数据属性: _year、edition，和一个访问器属性: year，最终的对象和上面定义的对象相同，唯一的区别是这里的属性都是在同一时间创建的。</p><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>通过Object构造函数和对象字面量都可以创建对象，但是这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码，为解决这个问题，人们开始使用工厂模式的一种变体。</p><h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，考虑到在ECMAScript中无法创建类，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPerson</span>(<span class="hljs-params">name, age, job</span>) </span>&#123;  <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()  o.name = name  o.age = age  o.job = job  o.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)  &#125;  <span class="hljs-keyword">return</span> o&#125;<span class="hljs-keyword">const</span> p1 = createPerson(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;engineer&#x27;</span>)<span class="hljs-keyword">const</span> p2 = createPerson(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;Doctor&#x27;</span>)<span class="hljs-built_in">console</span>.log(p1) <span class="hljs-comment">// &#123;name: &#x27;张三&#x27;, age: 18, job: &#x27;engineer&#x27;, sayName: : f() &#123;&#125;&#125;</span><span class="hljs-built_in">console</span>.log(p2) <span class="hljs-comment">// &#123;name: &#x27;李四&#x27;, age: 19, job: &#x27;Doctor&#x27;, sayName: : f() &#123;&#125;&#125;</span></code></pre><p>函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象，可以无数次的调用这个函数，每次调用都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题(即怎么知道一个对象的类型)，随着JavaScript的发展，又一个新模式出现了： 构造函数模式</p><h5 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h5><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, job</span>) </span>&#123;  <span class="hljs-built_in">this</span>.name = name  <span class="hljs-built_in">this</span>.age = age  <span class="hljs-built_in">this</span>.job = job  <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)  &#125;&#125;<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;engineer&#x27;</span>)<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;Doctor&#x27;</span>)<span class="hljs-built_in">console</span>.log(p1) <span class="hljs-comment">// &#123;name: &#x27;张三&#x27;, age: 18, job: &#x27;engineer&#x27;, sayName: : f() &#123;&#125;&#125;</span><span class="hljs-built_in">console</span>.log(p2) <span class="hljs-comment">// &#123;name: &#x27;李四&#x27;, age: 19, job: &#x27;Doctor&#x27;, sayName: : f() &#123;&#125;&#125;</span></code></pre><p>Person()函数取代了工厂模式的createPerson()函数。Person()与createPerson()的区别：</p></li><li><p>没有显式的创建对象</p></li><li><p>直接将属性和方法赋值给了this对象</p></li><li><p>没有return语句<br>要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p></li><li><p>1，创建一个新对象</p></li><li><p>2，将构造函数的作用域赋值给新对象（因此this就指向了这个新对象）</p></li><li><p>3，执行构造函数中的方法（为这个新对象添加属性）</p></li><li><p>4，返回新对象<br>以上例子p1和p2分别保存着Person的一个不同的实例。这两个对象都有一个constructor属性，该属性指向Person</p><pre><code class="hljs ini"><span class="hljs-attr">p1.constructor</span> == Person // <span class="hljs-literal">true</span><span class="hljs-attr">p2.constructor</span> == Person // <span class="hljs-literal">true</span></code></pre><p>对象的constructor属性起初是用来标识对象类型的。但是提到检测对象类型，还是instanceof操作符更可靠一些。我们在这个例子中创建的所有对象既是Object的实例，又是Person的实例，这一点可以通过instanceof检测：</p><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>)  <span class="hljs-regexp">//</span> <span class="hljs-literal">true</span><span class="hljs-built_in">console</span>.log(p2 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>)  <span class="hljs-regexp">//</span> <span class="hljs-literal">true</span><span class="hljs-built_in">console</span>.log(p1 <span class="hljs-keyword">instanceof</span> Person)  <span class="hljs-regexp">//</span> <span class="hljs-literal">true</span><span class="hljs-built_in">console</span>.log(p1 <span class="hljs-keyword">instanceof</span> Person)  <span class="hljs-regexp">//</span> <span class="hljs-literal">true</span></code></pre><p>p1、p2之所以同时是Object的实例，是因为所有对象均继承Object。</p></li></ul><h5 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h5><p>构造函数和普通函数的唯一区别在于调用他们的方式不同</p><p>前面的例子定义的Person()函数可以通过下面任意一种方式调用：</p><pre><code class="hljs dart"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;engineer&#x27;</span>)p1.sayName()  <span class="hljs-comment">// 张三</span>Person(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;Doctor&#x27;</span>)<span class="hljs-built_in">window</span>.sayName()  <span class="hljs-comment">// 李四</span><span class="hljs-keyword">const</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()Person.call(o, <span class="hljs-string">&#x27;小王&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;Nurse&#x27;</span>)o.sayName()  <span class="hljs-comment">// 小王</span></code></pre><p>以上代码，前两行展示了构造函数的典型用法，即使用new操作符来创建一个新对象。楼下两行代码展示了不使用new操作符调用Person()会出现什么结果： 属性和方法被添加给window对象了, 当在全局作用域中调用一个函数时，this对象总是指向Global对象(在浏览器中就是window对象)。最后两行代码使用call()在某个特殊对象的作用域中调用Person()函数，这里是在对象o的作用域中调用的。</p><h5 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h5><p>构造函数虽然好用，但也并非没有缺点，使用构造函数的主要问题就是每个方法都要在每个实例上重新创建一遍，在前面的例子中,p1、p2都有一个名为sayName()的方法，但这两个方法不是同一个Function的实例，ECMAScript中的函数是对象，因此每定义一个函数也就是实例化了一个对象，从逻辑角度讲，此时的构造函数也可以这样定义：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;  <span class="hljs-built_in">this</span>.name = name  <span class="hljs-built_in">this</span>.age = age  <span class="hljs-built_in">this</span>.sayName = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name))&#125;<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)  <span class="hljs-comment">// 张三</span></code></pre><p>以上代码更容易明白每个Person实例都包含一个不同的Function实例的本质。不同实例上的同名函数是不相等的以下代码可以证明：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;  <span class="hljs-built_in">this</span>.name = name  <span class="hljs-built_in">this</span>.age = age  <span class="hljs-built_in">this</span>.sayName = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name))&#125;<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)<span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">18</span>)<span class="hljs-built_in">console</span>.log(p1.sayName == p2.sayName)  <span class="hljs-comment">// false</span></code></pre><p>创建两个完成同样任务的Function实例的确没有必要，况且有this对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;  <span class="hljs-built_in">this</span>.name = name  <span class="hljs-built_in">this</span>.age = age  <span class="hljs-built_in">this</span>.sayName = sayName&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayName</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)&#125;<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>)<span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">18</span>)<span class="hljs-built_in">console</span>.log(p1.sayName())  <span class="hljs-comment">// 张三</span><span class="hljs-built_in">console</span>.log(p2.sayName())  <span class="hljs-comment">// 李四</span></code></pre><p>以上代码，sayName()函数的定义转移到了构造函数外。在构造函数内，我们将sayName属性设置成等于全局的sayName函数，这样，由于sayName包含的是一个指向函数的指针，因此p1和p2对象就共享了在全局作用域中定义的同一个sayName()函数，这样做确实解决了两个函数做同一件事的问题，但是新的问题来了，在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。更让人无法接受的是，如果对象需要定义很多方法，那么就要定义很多全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了，好在这些问题可以通过使用原型模式来解决</p><h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><p>每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用对象的好处是可以让所有对象实例共享他包含的属性和方法，换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子</p><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Person()</span> &#123;&#125;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>prototype.name = &#x27;张三&#x27;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>prototype.age = <span class="hljs-number">18</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>prototype.sayName = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;    console.log(this.name)&#125;<span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Person()</span>p1.say<span class="hljs-constructor">Name()</span><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Person()</span>p2.say<span class="hljs-constructor">Name()</span>console.log(p1.sayName<span class="hljs-operator"> == </span>p2.sayName)  <span class="hljs-comment">// true</span></code></pre><p>以上代码就是原型模式，和构造函数模式不用的是，新对象的这些属性和方法是由所有实例共享的。换句话说，p1和p2访问的都是同一组属性和同一个方法。</p><h6 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h6><p>只要创建一个函数，就会根据特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性是一个指向prototype属性所在函数的指针。以上例子，Person.prototype.constructor指向Person,通过这个构造函数我们可以继续为原型对象添加其他属性和方法。</p><p>创建了自定义的构造函数后，其原型对象默认只会取得constructor属性，至于其他方法，则都是从Object继承来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是OO语言中最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和实现继承实现继承。</p><p>接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承。而且实现继承主要是依靠原型链来实现的。</p><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>原型链是实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><p>简单回顾一下，构造函数、原型和实例的关系：每个构造函数都有一个原型对象</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
